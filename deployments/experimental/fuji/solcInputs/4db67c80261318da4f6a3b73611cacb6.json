{
  "language": "Solidity",
  "sources": {
    "contracts/Holograph.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/IInitializable.sol\";\nimport \"./interface/IHolograph.sol\";\n\ncontract Holograph is Admin, Initializable, IHolograph {\n  bytes32 constant _chainTypeSlot = 0x559ee1ab52f1e7dce7933c1945873a89fe5a5eb9f9bac817ed5387cc33fb88b9;\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  bytes32 constant _factorySlot = 0xa49f20855ba576e09d13c8041c8039fa655356ea27f6c40f1ec46a4301cd5b23;\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n  bytes32 constant _treasurySlot = 0x4215e7a38d75164ca078bbd61d0992cdeb1ba16f3b3ead5944966d3e4080e8b6;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (\n      uint32 chainType,\n      address bridge,\n      address factory,\n      address interfaces,\n      address operator,\n      address registry,\n      address treasury\n    ) = abi.decode(data, (uint32, address, address, address, address, address, address));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_chainTypeSlot, chainType)\n      sstore(_bridgeSlot, bridge)\n      sstore(_factorySlot, factory)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_operatorSlot, operator)\n      sstore(_registrySlot, registry)\n      sstore(_treasurySlot, treasury)\n    }\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function getChainType() external view returns (uint32 chainType) {\n    assembly {\n      chainType := sload(_chainTypeSlot)\n    }\n  }\n\n  function setChainType(uint32 chainType) external onlyAdmin {\n    assembly {\n      sstore(_chainTypeSlot, chainType)\n    }\n  }\n\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  function getFactory() external view returns (address factory) {\n    assembly {\n      factory := sload(_factorySlot)\n    }\n  }\n\n  function setFactory(address factory) external onlyAdmin {\n    assembly {\n      sstore(_factorySlot, factory)\n    }\n  }\n\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  function getTreasury() external view returns (address treasury) {\n    assembly {\n      treasury := sload(_treasurySlot)\n    }\n  }\n\n  function setTreasury(address treasury) external onlyAdmin {\n    assembly {\n      sstore(_treasurySlot, treasury)\n    }\n  }\n\n  receive() external payable {\n    revert();\n  }\n\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "contracts/abstract/Admin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract Admin {\n  bytes32 constant _adminSlot = 0x3f106594dc74eeef980dae234cde8324dc2497b13d27a0c59e55bd2ca10a07c9;\n\n  constructor() {}\n\n  modifier onlyAdmin() {\n    require(msg.sender == getAdmin(), \"HOLOGRAPH: admin only function\");\n    _;\n  }\n\n  function admin() public view returns (address) {\n    return getAdmin();\n  }\n\n  function getAdmin() public view returns (address adminAddress) {\n    assembly {\n      adminAddress := sload(_adminSlot)\n    }\n  }\n\n  function setAdmin(address adminAddress) public onlyAdmin {\n    assembly {\n      sstore(_adminSlot, adminAddress)\n    }\n  }\n\n  function adminCall(address target, bytes calldata data) external payable onlyAdmin {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/abstract/Initializable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/IInitializable.sol\";\n\nabstract contract Initializable is IInitializable {\n  bytes32 constant _initializedSlot = 0x4e5f991bca30eca2d4643aaefa807e88f96a4a97398933d572a3c0d973004a01;\n\n  function init(bytes memory _data) external virtual returns (bytes4);\n\n  function _isInitialized() internal view returns (bool initialized) {\n    assembly {\n      initialized := sload(_initializedSlot)\n    }\n  }\n\n  function _setInitialized() internal {\n    assembly {\n      sstore(_initializedSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n    }\n  }\n}\n"
    },
    "contracts/interface/IInitializable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface IInitializable {\n  function init(bytes memory _data) external returns (bytes4);\n}\n"
    },
    "contracts/interface/IHolograph.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface IHolograph {\n  function getChainType() external view returns (uint32 chainType);\n\n  function getBridge() external view returns (address bridgeAddress);\n\n  function getFactory() external view returns (address factoryAddress);\n\n  function getInterfaces() external view returns (address interfacesAddress);\n\n  function getOperator() external view returns (address operatorAddress);\n\n  function getRegistry() external view returns (address registryAddress);\n}\n"
    },
    "contracts/token/hToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/ERC20H.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/ERC20Holograph.sol\";\nimport \"../interface/IHolograph.sol\";\nimport \"../interface/IHolographer.sol\";\n\n/**\n * @title Holograph token (aka hToken), used to wrap and bridge native tokens across blockchains.\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph's Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract hToken is ERC20H {\n  /**\n   * @dev Sample fee for unwrapping.\n   */\n  uint16 private _feeBp; // 10000 == 100.00%\n\n  /**\n   * @dev List of supported Wrapped Tokens (equivalent), on current-chain.\n   */\n  mapping(address => bool) private _supportedWrappers;\n\n  /**\n   * @dev Event that is triggered when native token is converted into hToken.\n   */\n  event Deposit(address indexed from, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when ERC20 token is converted into hToken.\n   */\n  event TokenDeposit(address indexed token, address indexed from, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when hToken is converted into native token.\n   */\n  event Withdrawal(address indexed to, uint256 amount);\n\n  /**\n   * @dev Event that is triggered when hToken is converted into ERC20 token.\n   */\n  event TokenWithdrawal(address indexed token, address indexed to, uint256 amount);\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n   */\n  constructor() {}\n\n  /**\n   * @notice Initializes the token.\n   * @dev Special function to allow a one time initialisation on deployment.\n   */\n  function init(bytes memory data) external override returns (bytes4) {\n    (address contractOwner, uint16 fee) = abi.decode(data, (address, uint16));\n    _setOwner(contractOwner);\n    _feeBp = fee;\n    // run underlying initializer logic\n    return _init(data);\n  }\n\n  /**\n   * @dev Send native token value, get back hToken equivalent.\n   * @param recipient Address of where to send the hToken(s) to.\n   */\n  function holographNativeToken(address recipient) external payable onlyHolographer {\n    require(\n      (IHolographer(holographer()).getOriginChain() ==\n        IHolograph(IHolographer(holographer()).getHolograph()).getChainType()),\n      \"hToken: not native token\"\n    );\n    require(msg.value > 0, \"hToken: no value received\");\n    address sender = msgSender();\n    if (recipient == address(0)) {\n      recipient = sender;\n    }\n    ERC20Holograph(holographer()).sourceMint(recipient, msg.value);\n    emit Deposit(sender, msg.value);\n  }\n\n  /**\n   * @dev Send hToken, get back native token value equivalent.\n   * @param recipient Address of where to send the native token(s) to.\n   */\n  function extractNativeToken(address payable recipient, uint256 amount) external onlyHolographer {\n    address sender = msgSender();\n    require(ERC20(address(this)).balanceOf(sender) >= amount, \"hToken: not enough hToken(s)\");\n    require(\n      (IHolographer(holographer()).getOriginChain() ==\n        IHolograph(IHolographer(holographer()).getHolograph()).getChainType()),\n      \"hToken: not on native chain\"\n    );\n    require(address(this).balance >= amount, \"hToken: not enough native tokens\");\n    ERC20Holograph(holographer()).sourceBurn(sender, amount);\n    // HERE WE NEED TO ADD FEE MECHANISM TO EXTRACT xx.xxxx% FROM NATIVE TOKEN AMOUNT\n    // THIS SHOULD GO SOMEWHERE TO REWARD CAPITAL PROVIDERS\n    uint256 fee = (amount / 10000) * _feeBp;\n    // for now we just leave fee in contract balance\n    //\n    // amount is updated to reflect fee subtraction\n    amount = amount - fee;\n    recipient.transfer(amount);\n    emit Withdrawal(recipient, amount);\n  }\n\n  /**\n   * @dev Send supported wrapped token, get back hToken equivalent.\n   * @param recipient Address of where to send the hToken(s) to.\n   */\n  function holographWrappedToken(\n    address token,\n    address recipient,\n    uint256 amount\n  ) external onlyHolographer {\n    require(_supportedWrappers[token], \"hToken: unsupported token type\");\n    ERC20 erc20 = ERC20(token);\n    address sender = msgSender();\n    require(erc20.allowance(sender, address(this)) >= amount, \"hToken: allowance too low\");\n    uint256 previousBalance = erc20.balanceOf(address(this));\n    require(erc20.transferFrom(sender, address(this), amount), \"hToken: ERC20 transfer failed\");\n    uint256 currentBalance = erc20.balanceOf(address(this));\n    uint256 difference = currentBalance - previousBalance;\n    require(difference >= 0, \"hToken: no tokens transferred\");\n    if (difference < amount) {\n      // adjust for fee-based mechanisms\n      // this allows for discrepancies to not fail the entire operation\n      amount = difference;\n    }\n    if (recipient == address(0)) {\n      recipient = sender;\n    }\n    ERC20Holograph(holographer()).sourceMint(recipient, amount);\n    emit TokenDeposit(token, sender, amount);\n  }\n\n  /**\n   * @dev Send hToken, get back native token value equivalent.\n   * @param recipient Address of where to send the native token(s) to.\n   */\n  function extractWrappedToken(\n    address token,\n    address payable recipient,\n    uint256 amount\n  ) external onlyHolographer {\n    require(_supportedWrappers[token], \"hToken: unsupported token type\");\n    address sender = msgSender();\n    require(ERC20(address(this)).balanceOf(sender) >= amount, \"hToken: not enough hToken(s)\");\n    ERC20 erc20 = ERC20(token);\n    uint256 previousBalance = erc20.balanceOf(address(this));\n    require(previousBalance >= amount, \"hToken: not enough ERC20 tokens\");\n    if (recipient == address(0)) {\n      recipient = payable(sender);\n    }\n    // HERE WE NEED TO ADD FEE MECHANISM TO EXTRACT xx.xxxx% FROM NATIVE TOKEN AMOUNT\n    // THIS SHOULD GO SOMEWHERE TO REWARD CAPITAL PROVIDERS\n    uint256 fee = (amount / 10000) * _feeBp;\n    uint256 adjustedAmount = amount - fee;\n    // for now we just leave fee in contract balance\n    erc20.transfer(recipient, adjustedAmount);\n    uint256 currentBalance = erc20.balanceOf(address(this));\n    uint256 difference = currentBalance - previousBalance;\n    require(difference == adjustedAmount, \"hToken: incorrect new balance\");\n    ERC20Holograph(holographer()).sourceBurn(sender, amount);\n    emit TokenWithdrawal(token, recipient, adjustedAmount);\n  }\n\n  function availableNativeTokens() external view onlyHolographer returns (uint256) {\n    if (\n      IHolographer(holographer()).getOriginChain() ==\n      IHolograph(IHolographer(holographer()).getHolograph()).getChainType()\n    ) {\n      return address(this).balance;\n    } else {\n      return 0;\n    }\n  }\n\n  function availableWrappedTokens(address token) external view onlyHolographer returns (uint256) {\n    require(_supportedWrappers[token], \"hToken: unsupported token type\");\n    return ERC20(token).balanceOf(address(this));\n  }\n\n  function updateSupportedWrapper(address token, bool supported) external onlyHolographer onlyOwner {\n    _supportedWrappers[token] = supported;\n  }\n}\n"
    },
    "contracts/abstract/ERC20H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC20H is Initializable {\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC20: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == holographer()) {\n      require(msgSender() == _getOwner(), \"ERC20: owner only function\");\n    } else {\n      require(msg.sender == _getOwner(), \"ERC20: owner only function\");\n    }\n    _;\n  }\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n   */\n  constructor() {}\n\n  /**\n   * @notice Initializes the collection.\n   * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n   */\n  function init(bytes memory data) external virtual override returns (bytes4) {\n    return _init(data);\n  }\n\n  function _init(\n    bytes memory /* data*/\n  ) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    address _holographer = msg.sender;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n    }\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal pure returns (address sender) {\n    assembly {\n      sender := calldataload(sub(calldatasize(), 0x20))\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC20 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the token contract.\n   */\n  function owner() external view returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    if (msg.sender == holographer()) {\n      return msgSender() == _getOwner();\n    } else {\n      return msg.sender == _getOwner();\n    }\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  /**\n   * @dev Defined here to suppress compiler warnings\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "contracts/interface/ERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address _owner) external view returns (uint256 balance);\n\n  function transfer(address _to, uint256 _value) external returns (bool success);\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool success);\n\n  function approve(address _spender, uint256 _value) external returns (bool success);\n\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"
    },
    "contracts/interface/ERC20Holograph.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./ERC20.sol\";\nimport \"./ERC20Burnable.sol\";\nimport \"./ERC20Metadata.sol\";\nimport \"./ERC20Permit.sol\";\nimport \"./ERC20Receiver.sol\";\nimport \"./ERC20Safer.sol\";\nimport \"./ERC165.sol\";\nimport \"./HolographableEnforcer.sol\";\n\ninterface ERC20Holograph is\n  ERC165,\n  ERC20,\n  ERC20Burnable,\n  ERC20Metadata,\n  ERC20Receiver,\n  ERC20Safer,\n  ERC20Permit,\n  HolographableEnforcer\n{\n  function holographBridgeMint(address to, uint256 amount) external returns (bytes4);\n\n  function sourceBurn(address from, uint256 amount) external;\n\n  function sourceMint(address to, uint256 amount) external;\n\n  function sourceMintBatch(address[] calldata wallets, uint256[] calldata amounts) external;\n\n  function sourceTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) external;\n}\n"
    },
    "contracts/interface/IHolographer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface IHolographer {\n  function getOriginChain() external view returns (uint32);\n\n  function getHolograph() external view returns (address);\n\n  function getHolographEnforcer() external view returns (address payable);\n\n  function getSecureStorage() external pure returns (address);\n\n  function getSourceContract() external pure returns (address payable);\n}\n"
    },
    "contracts/interface/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Burnable {\n  function burn(uint256 amount) external;\n\n  function burnFrom(address account, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/interface/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Metadata {\n  function decimals() external view returns (uint8);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/interface/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity 0.8.13;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface ERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``account``'s tokens,\n   * given ``account``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `account`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``account``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address account,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `account`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``account``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address account) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/interface/ERC20Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Receiver {\n  function onERC20Received(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bytes4);\n}\n"
    },
    "contracts/interface/ERC20Safer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC20Safer {\n  function safeTransfer(address recipient, uint256 amount) external returns (bool);\n\n  function safeTransfer(\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bool);\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) external returns (bool);\n}\n"
    },
    "contracts/interface/ERC165.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\ninterface ERC165 {\n  /// @notice Query if a contract implements an interface\n  /// @param interfaceID The interface identifier, as specified in ERC-165\n  /// @dev Interface identification is specified in ERC-165. This function\n  ///  uses less than 30,000 gas.\n  /// @return `true` if the contract implements `interfaceID` and\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interface/HolographableEnforcer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface HolographableEnforcer {\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external returns (bytes4);\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external returns (bytes4 selector, bytes memory data);\n}\n"
    },
    "contracts/token/HolographUtilityToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/ERC20H.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/ERC20Holograph.sol\";\nimport \"../interface/IHolograph.sol\";\nimport \"../interface/IHolographer.sol\";\n\n/**\n * @title Holograph Utility Token.\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph's ERC20 Utility Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographUtilityToken is ERC20H {\n  constructor() {}\n\n  /**\n   * @notice Initializes the token.\n   * @dev Special function to allow a one time initialisation on deployment.\n   */\n  function init(bytes memory data) external override returns (bytes4) {\n    address contractOwner = abi.decode(data, (address));\n    _setOwner(contractOwner);\n    // run underlying initializer logic\n    return _init(data);\n  }\n}\n"
    },
    "contracts/token/SampleERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/StrictERC20H.sol\";\n\nimport \"../interface/ERC20Holograph.sol\";\n\n/**\n * @title Sample ERC-20 token that is bridgeable via Holograph\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract SampleERC20 is StrictERC20H {\n  /**\n   * @dev Just a dummy value for now to test transferring of data.\n   */\n  mapping(address => bytes32) private _walletSalts;\n\n  /**\n   * @dev Temporary implementation to suppress compiler state mutability warnings.\n   */\n  bool private _dummy;\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n   */\n  constructor() {}\n\n  /**\n   * @notice Initializes the collection.\n   * @dev Special function to allow a one time initialisation on deployment.\n   */\n  function init(bytes memory data) external override returns (bytes4) {\n    // do your own custom logic here\n    address contractOwner = abi.decode(data, (address));\n    _setOwner(contractOwner);\n    // run underlying initializer logic\n    return _init(data);\n  }\n\n  /**\n   * @dev Sample mint where anyone can mint any amounts of tokens.\n   */\n  function mint(address to, uint256 amount) external onlyHolographer onlyOwner {\n    ERC20Holograph(holographer()).sourceMint(to, amount);\n    if (_walletSalts[to] == bytes32(0)) {\n      _walletSalts[to] = keccak256(\n        abi.encodePacked(to, amount, block.timestamp, block.number, blockhash(block.number - 1))\n      );\n    }\n  }\n\n  function bridgeIn(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address _to,\n    uint256, /* _amount*/\n    bytes calldata _data\n  ) external override onlyHolographer returns (bool) {\n    bytes32 salt = abi.decode(_data, (bytes32));\n    _walletSalts[_to] = salt;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address _to,\n    uint256 /* _amount*/\n  ) external override onlyHolographer returns (bytes memory _data) {\n    _dummy = false;\n    _data = abi.encode(_walletSalts[_to]);\n  }\n}\n"
    },
    "contracts/abstract/StrictERC20H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/HolographedERC20.sol\";\n\nimport \"./ERC20H.sol\";\n\nabstract contract StrictERC20H is ERC20H, HolographedERC20 {\n  /**\n   * @dev Dummy variable to prevent empty functions from making \"switch to pure\" warnings.\n   */\n  bool private _success;\n\n  function bridgeIn(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool) {\n    _success = true;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bytes memory _data) {\n    /**\n     * @dev This is just here to suppress unused parameter warning\n     */\n    _data = abi.encodePacked(holographer());\n    _success = true;\n  }\n\n  function afterApprove(\n    address, /* _owner*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprove(\n    address, /* _owner*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterOnERC20Received(\n    address, /* _token*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeOnERC20Received(\n    address, /* _token*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterBurn(\n    address, /* _owner*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeBurn(\n    address, /* _owner*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterMint(\n    address, /* _owner*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeMint(\n    address, /* _owner*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterSafeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeSafeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n}\n"
    },
    "contracts/interface/HolographedERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @title Holograph ERC-20 Fungible Token Standard\n/// @dev See https://holograph.network/standard/ERC-20\n///  Note: the ERC-165 identifier for this interface is 0xFFFFFFFF.\ninterface HolographedERC20 {\n  // event id = 1\n  function bridgeIn(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 2\n  function bridgeOut(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external returns (bytes memory _data);\n\n  // event id = 3\n  function afterApprove(\n    address _owner,\n    address _to,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 4\n  function beforeApprove(\n    address _owner,\n    address _to,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 5\n  function afterOnERC20Received(\n    address _token,\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 6\n  function beforeOnERC20Received(\n    address _token,\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 7\n  function afterBurn(address _owner, uint256 _amount) external returns (bool success);\n\n  // event id = 8\n  function beforeBurn(address _owner, uint256 _amount) external returns (bool success);\n\n  // event id = 9\n  function afterMint(address _owner, uint256 _amount) external returns (bool success);\n\n  // event id = 10\n  function beforeMint(address _owner, uint256 _amount) external returns (bool success);\n\n  // event id = 11\n  function afterSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 12\n  function beforeSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 13\n  function afterTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 14\n  function beforeTransfer(\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external returns (bool success);\n}\n"
    },
    "contracts/proxy/HolographTreasuryProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/IInitializable.sol\";\n\ncontract HolographTreasuryProxy is Admin, Initializable {\n  bytes32 constant _treasurySlot = 0x4215e7a38d75164ca078bbd61d0992cdeb1ba16f3b3ead5944966d3e4080e8b6;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address treasury, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_treasurySlot, treasury)\n    }\n    (bool success, bytes memory returnData) = treasury.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == IInitializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function getTreasury() external view returns (address treasury) {\n    assembly {\n      treasury := sload(_treasurySlot)\n    }\n  }\n\n  function setTreasury(address treasury) external onlyAdmin {\n    assembly {\n      sstore(_treasurySlot, treasury)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let treasury := sload(_treasurySlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), treasury, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/proxy/HolographRegistryProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/IInitializable.sol\";\n\ncontract HolographRegistryProxy is Admin, Initializable {\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address registry, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_registrySlot, registry)\n    }\n    (bool success, bytes memory returnData) = registry.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == IInitializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let registry := sload(_registrySlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), registry, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/proxy/HolographOperatorProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/IInitializable.sol\";\n\ncontract HolographOperatorProxy is Admin, Initializable {\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address operator, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_operatorSlot, operator)\n    }\n    (bool success, bytes memory returnData) = operator.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == IInitializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let operator := sload(_operatorSlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), operator, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/proxy/HolographFactoryProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/IInitializable.sol\";\n\ncontract HolographFactoryProxy is Admin, Initializable {\n  bytes32 constant _factorySlot = 0xa49f20855ba576e09d13c8041c8039fa655356ea27f6c40f1ec46a4301cd5b23;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address factory, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_factorySlot, factory)\n    }\n    (bool success, bytes memory returnData) = factory.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == IInitializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function getFactory() external view returns (address factory) {\n    assembly {\n      factory := sload(_factorySlot)\n    }\n  }\n\n  function setFactory(address factory) external onlyAdmin {\n    assembly {\n      sstore(_factorySlot, factory)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let factory := sload(_factorySlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), factory, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/proxy/HolographBridgeProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/IInitializable.sol\";\n\ncontract HolographBridgeProxy is Admin, Initializable {\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, bytes memory initCode) = abi.decode(data, (address, bytes));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_bridgeSlot, bridge)\n    }\n    (bool success, bytes memory returnData) = bridge.delegatecall(abi.encodeWithSignature(\"init(bytes)\", initCode));\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == IInitializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    assembly {\n      let bridge := sload(_bridgeSlot)\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), bridge, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/proxy/CxipERC721Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\nimport \"../abstract/Initializable.sol\";\n\nimport \"../interface/IInitializable.sol\";\nimport \"../interface/IHolographRegistry.sol\";\n\ncontract CxipERC721Proxy is Admin, Initializable {\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (bytes32 contractType, address registry, bytes memory initCode) = abi.decode(data, (bytes32, address, bytes));\n    assembly {\n      sstore(_contractTypeSlot, contractType)\n      sstore(_registrySlot, registry)\n    }\n    (bool success, bytes memory returnData) = getCxipERC721Source().delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == IInitializable.init.selector, \"initialization failed\");\n\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function getCxipERC721Source() public view returns (address) {\n    IHolographRegistry registry;\n    bytes32 contractType;\n    assembly {\n      registry := sload(_registrySlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return registry.getContractTypeAddress(contractType);\n  }\n\n  receive() external payable {}\n\n  fallback() external payable {\n    address cxipErc721Source = getCxipERC721Source();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), cxipErc721Source, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/interface/IHolographRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface IHolographRegistry {\n  function referenceContractTypeAddress(address contractAddress) external returns (bytes32);\n\n  function setContractTypeAddress(bytes32 contractType, address contractAddress) external;\n\n  function setHToken(uint32 chainId, address hToken) external;\n\n  function updateReservedContractTypes(bytes32[] calldata hashes, bool[] calldata reserved) external;\n\n  function getContractTypeAddress(bytes32 contractType) external view returns (address);\n\n  function factoryDeployedHash(bytes32 hash, address contractAddress) external;\n\n  function getHolographedHashAddress(bytes32 hash) external view returns (address);\n\n  function getHToken(uint32 chainId) external view returns (address hToken);\n\n  function getUtilityToken() external view returns (address tokenContract);\n\n  function isHolographedContract(address smartContract) external view returns (bool);\n\n  function isHolographedHashDeployed(bytes32 hash) external view returns (bool);\n}\n"
    },
    "contracts/Holographer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/IHolograph.sol\";\nimport \"./interface/IHolographRegistry.sol\";\nimport \"./interface/IInitializable.sol\";\n\n/**\n * @dev This contract is a binder. It puts together all the variables to make the underlying contracts functional and be bridgeable.\n */\ncontract Holographer is Admin, Initializable {\n  bytes32 constant _originChainSlot = 0xd49ffd6af8249d6e6b5963d9d2b22c6db30ad594cb468453047a14e1c1bcde4d;\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  bytes32 constant _contractTypeSlot = 0x0b671eb65810897366dd82c4cbb7d9dff8beda8484194956e81e89b8a361d9c7;\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n  bytes32 constant _blockHeightSlot = 0x9172848b0f1df776dc924b58e7fa303087ae0409bbf611608529e7f747d55de3;\n\n  /**\n   * @dev Constructor is left empty and only the admin address is set.\n   */\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPHER: already initialized\");\n    (bytes memory encoded, bytes memory initCode) = abi.decode(data, (bytes, bytes));\n    (uint32 originChain, address holograph, bytes32 contractType, address sourceContract) = abi.decode(\n      encoded,\n      (uint32, address, bytes32, address)\n    );\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_originChainSlot, originChain)\n      sstore(_holographSlot, holograph)\n      sstore(_contractTypeSlot, contractType)\n      sstore(_sourceContractSlot, sourceContract)\n      sstore(_blockHeightSlot, number())\n    }\n    (bool success, bytes memory returnData) = getHolographEnforcer().delegatecall(\n      abi.encodeWithSignature(\"init(bytes)\", initCode)\n    );\n    bytes4 selector = abi.decode(returnData, (bytes4));\n    require(success && selector == IInitializable.init.selector, \"initialization failed\");\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  /**\n   * @dev Returns the block height of when the smart contract was deployed. Useful for retrieving deployment config for re-deployment on other EVM-compatible chains.\n   */\n  function getDeploymentBlock() public view returns (address holograph) {\n    assembly {\n      holograph := sload(_blockHeightSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the Holograph smart contract.\n   */\n  function getHolograph() public view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the Holograph smart contract that controls and enforces the ERC standards.\n   */\n  function getHolographEnforcer() public view returns (address payable) {\n    IHolograph holograph;\n    bytes32 contractType;\n    assembly {\n      holograph := sload(_holographSlot)\n      contractType := sload(_contractTypeSlot)\n    }\n    return payable(IHolographRegistry(holograph.getRegistry()).getContractTypeAddress(contractType));\n  }\n\n  /**\n   * @dev Returns the original chain that contract was deployed on.\n   */\n  function getOriginChain() public view returns (uint32 originChain) {\n    assembly {\n      originChain := sload(_originChainSlot)\n    }\n  }\n\n  /**\n   * @dev Returns a hardcoded address for the custom secure storage contract deployed in parallel with this contract deployment.\n   */\n  function getSourceContract() public view returns (address payable sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @dev This takes the Enforcer's source code, runs it, and uses current address for storage slots.\n   */\n  fallback() external payable {\n    address holographEnforcer = getHolographEnforcer();\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      let result := delegatecall(gas(), holographEnforcer, 0, calldatasize(), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/HolographFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./Holographer.sol\";\n\nimport \"./interface/HolographableEnforcer.sol\";\nimport \"./interface/IHolograph.sol\";\nimport \"./interface/IHolographRegistry.sol\";\nimport \"./interface/IInitializable.sol\";\n\nimport \"./struct/DeploymentConfig.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @dev This smart contract demonstrates a clear and concise way that we plan to deploy smart contracts.\n * @dev With the goal of deploying replicate-able non-fungible token smart contracts through this process.\n * @dev This is just the first step. But it is fundamental for achieving cross-chain non-fungible tokens.\n */\ncontract HolographFactory is Admin, Initializable, HolographableEnforcer {\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev This event is fired every time that a bridgeable contract is deployed.\n   */\n  event BridgeableContractDeployed(address indexed contractAddress, bytes32 indexed hash);\n\n  /**\n   * @dev Constructor is left empty and only the admin address is set.\n   */\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address holograph, address registry) = abi.decode(data, (address, address));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_holographSlot, holograph)\n      sstore(_registrySlot, registry)\n    }\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function bridgeIn(\n    uint32,\n    /* fromChain*/\n    bytes calldata payload\n  ) external returns (bytes4) {\n    (DeploymentConfig memory config, Verification memory signature, address signer) = abi.decode(\n      payload,\n      (DeploymentConfig, Verification, address)\n    );\n    deployHolographableContract(config, signature, signer);\n    return HolographableEnforcer.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32,\n    /* toChain*/\n    address,\n    /* sender*/\n    bytes calldata payload\n  ) external pure returns (bytes4 selector, bytes memory data) {\n    return (HolographableEnforcer.bridgeOut.selector, payload);\n  }\n\n  /**\n   * @dev A sample function of the deployment of bridgeable smart contracts.\n   * @dev The used variables and formatting is not the final or decisive version, but the general idea is directly portrayed.\n   * @notice In this function we have incorporated a secure storage function/extension. Keep in mind that this is not required or needed for bridgeable deployments to work. It is just a personal development choice.\n   */\n  function deployHolographableContract(\n    DeploymentConfig memory config,\n    Verification memory signature,\n    address signer\n  ) public {\n    bytes32 hash = keccak256(\n      abi.encodePacked(\n        config.contractType,\n        config.chainType,\n        config.salt,\n        keccak256(config.byteCode),\n        keccak256(config.initCode),\n        signer\n      )\n    );\n    require(_verifySigner(signature.r, signature.s, signature.v, hash, signer), \"HOLOGRAPH: invalid signature\");\n    require(!IHolographRegistry(getRegistry()).isHolographedHashDeployed(hash), \"HOLOGRAPH: already deployed\");\n    uint256 saltInt = uint256(hash);\n    address sourceContractAddress;\n    bytes memory sourceByteCode = config.byteCode;\n    assembly {\n      sourceContractAddress := create2(0, add(sourceByteCode, 0x20), mload(sourceByteCode), saltInt)\n    }\n    bytes memory holographerBytecode = type(Holographer).creationCode;\n    address holographerAddress;\n    assembly {\n      holographerAddress := create2(0, add(holographerBytecode, 0x20), mload(holographerBytecode), saltInt)\n    }\n    address holograph;\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n    require(\n      IInitializable(holographerAddress).init(\n        abi.encode(abi.encode(config.chainType, holograph, config.contractType, sourceContractAddress), config.initCode)\n      ) == IInitializable.init.selector,\n      \"initialization failed\"\n    );\n    IHolographRegistry(getRegistry()).factoryDeployedHash(hash, holographerAddress);\n    emit BridgeableContractDeployed(holographerAddress, hash);\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  function _verifySigner(\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    bytes32 hash,\n    address signer\n  ) private pure returns (bool) {\n    if (v < 27) {\n      v += 27;\n    }\n    return (ecrecover(hash, v, r, s) == signer ||\n      ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), v, r, s) == signer);\n  }\n\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  function getRegistry() public view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n}\n"
    },
    "contracts/struct/DeploymentConfig.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct DeploymentConfig {\n  bytes32 contractType;\n  uint32 chainType;\n  bytes32 salt;\n  bytes byteCode;\n  bytes initCode;\n}\n"
    },
    "contracts/struct/Verification.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct Verification {\n  bytes32 r;\n  bytes32 s;\n  uint8 v;\n}\n"
    },
    "contracts/interface/IHolographFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../struct/DeploymentConfig.sol\";\nimport \"../struct/Verification.sol\";\n\ninterface IHolographFactory {\n  event BridgeableContractDeployed(address indexed contractAddress, bytes32 indexed hash);\n\n  function getBridgeRegistry() external view returns (address bridgeRegistry);\n\n  function getSecureStorage() external view returns (address secureStorage);\n\n  function deployHolographableContract(\n    DeploymentConfig calldata config,\n    Verification calldata signature,\n    address signer\n  ) external;\n}\n"
    },
    "contracts/interface/IHolographBridge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../struct/DeploymentConfig.sol\";\nimport \"../struct/Verification.sol\";\n\ninterface IHolographBridge {\n  function bridgeInRequest(\n    uint256 nonce,\n    uint32 fromChain,\n    address holographableContract,\n    address hToken,\n    address hTokenRecipient,\n    uint256 hTokenValue,\n    bytes calldata data\n  ) external;\n\n  function bridgeOutRequest(\n    uint32 toChain,\n    address holographableContract,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata data\n  ) external payable;\n\n  function getBridgeOutRequestPayload(\n    uint32 toChain,\n    address holographableContract,\n    bytes calldata data\n  ) external view returns (bytes memory samplePayload);\n}\n"
    },
    "contracts/HolographOperator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./enum/ChainIdType.sol\";\n\nimport \"./interface/ERC20Holograph.sol\";\nimport \"./interface/IHolograph.sol\";\nimport \"./interface/IHolographBridge.sol\";\nimport \"./interface/IHolographOperator.sol\";\nimport \"./interface/IHolographRegistry.sol\";\nimport \"./interface/IInitializable.sol\";\nimport \"./interface/IInterfaces.sol\";\nimport \"./interface/ILayerZeroEndpoint.sol\";\nimport \"./interface/Ownable.sol\";\n\nimport \"./struct/OperatorJob.sol\";\n\n/**\n * @dev This smart contract contains the actual core operator logic.\n */\ncontract HolographOperator is Admin, Initializable, IHolographOperator {\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  bytes32 constant _deadAddressSlot = 0x0c01c0d9182738e91eab986a4ef4a5a120cc00ed5032b67c0bd8d0e70b247cf3;\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  bytes32 constant _jobNonceSlot = 0x1cda64803f3b43503042e00863791e8d996666552d5855a78d53ee1dd4b3286d;\n  bytes32 constant _lZEndpointSlot = 0x56825e447adf54cdde5f04815fcf9b1dd26ef9d5c053625147c18b7c13091686;\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev Internal number (in seconds), used for defining a window for operator to execute the job.\n   */\n  uint256 private _blockTime;\n\n  /**\n   * @dev Minimum amount of tokens needed for bonding.\n   */\n  uint256 private _baseBondAmount;\n\n  /**\n   * @dev The multiplier used for calculating bonding amount for pods.\n   */\n  uint256 private _podMultiplier;\n\n  /**\n   * @dev The threshold used for limiting number of operators in a pod.\n   */\n  uint256 private _operatorThreshold;\n\n  /**\n   * @dev The threshold step used for increasing bond amount once threshold is reached.\n   */\n  uint256 private _operatorThresholdStep;\n\n  /**\n   * @dev The threshold divisor used for increasing bond amount once threshold is reached.\n   */\n  uint256 private _operatorThresholdDivisor;\n\n  /**\n   * @dev Internal mapping of operator job details for a specific job hash.\n   */\n  mapping(bytes32 => uint256) private _operatorJobs;\n\n  /**\n   * @dev Internal mapping of operator addresses, used for temp storage when defining an operator job.\n   */\n  mapping(uint256 => address) private _operatorTempStorage;\n\n  /**\n   * @dev Internal index used for storing/referencing operator temp storage.\n   */\n  uint32 private _operatorTempStorageCounter;\n\n  /**\n   * @dev Multi-dimensional array of available operators.\n   */\n  address[][] private _operatorPods;\n\n  /**\n   * @dev Internal mapping of bonded operators, to prevent double bonding.\n   */\n  mapping(address => uint256) private _bondedOperators;\n\n  /**\n   * @dev Internal mapping of bonded operator amounts.\n   */\n  mapping(address => uint256) private _bondedAmounts;\n\n  /**\n   * @dev Event is emitted for every time that a valid job is available.\n   */\n  event AvailableOperatorJob(bytes32 jobHash, bytes payload);\n\n  modifier onlyBridge() {\n    require(msg.sender == _bridge(), \"HOLOGRAPH: bridge only call\");\n    _;\n  }\n\n  modifier onlyLZ() {\n    assembly {\n      // check if lzEndpoint\n      switch eq(sload(_lZEndpointSlot), caller())\n      case 0 {\n        // check if operator is calling self, used for job estimations\n        switch eq(address(), caller())\n        case 0 {\n          mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n          mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n          mstore(0xc0, 0x0000001b484f4c4f47524150483a204c5a206f6e6c7920656e64706f696e7400)\n          mstore(0xe0, 0x0000000000000000000000000000000000000000000000000000000000000000)\n          revert(0x80, 0xc4)\n        }\n      }\n    }\n    _;\n  }\n\n  /**\n   * @dev Constructor is left empty and only the admin address is set.\n   */\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, address holograph, address interfaces, address registry) = abi.decode(\n      data,\n      (address, address, address, address)\n    );\n    assembly {\n      // sstore(_deadAddressSlot, 0x000000000000000000000000000000000000000000000000000000000000dead)\n      sstore(_adminSlot, origin())\n\n      sstore(_bridgeSlot, bridge)\n      sstore(_holographSlot, holograph)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_registrySlot, registry)\n    }\n    _blockTime = 10; // 10 blocks allowed for execution\n    unchecked {\n      _baseBondAmount = 100 * (10**18); // one single token unit * 100\n    }\n    // how much to increase bond amount per pod\n    _podMultiplier = 2; // 1, 4, 16, 64\n    // starting pod max amount\n    _operatorThreshold = 1000;\n    // how often to increase price per each operator\n    _operatorThresholdStep = 10;\n    // we want to multiply by decimals, but instead will have to divide\n    _operatorThresholdDivisor = 100; // == * 0.01\n    // set first operator for each pod as zero address\n    _operatorPods = [[address(0)]];\n    // mark zero address as bonded operator, to prevent abuse\n    _bondedOperators[address(0)] = 1;\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function lzReceive(\n    uint16, /* _srcChainId*/\n    bytes calldata _srcAddress,\n    uint64, /* _nonce*/\n    bytes calldata _payload\n  ) external payable onlyLZ {\n    assembly {\n      let ptr := mload(0x40)\n      calldatacopy(add(ptr, 0x0c), _srcAddress.offset, _srcAddress.length)\n      switch eq(mload(ptr), address())\n      case 0 {\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x0000001e484f4c4f47524150483a20756e617574686f72697a65642073656e64)\n        mstore(0xe0, 0x6572000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n    }\n    // would be a good idea to check payload gas price here and if it is significantly lower than current amount, to set zero address as operator to not lock-up an operator unnecessarily\n    unchecked {\n      bytes32 jobHash = keccak256(_payload);\n      ++_operatorTempStorageCounter;\n      // use job hash, job nonce, block number, and block timestamp for generating a random number\n      uint256 random = uint256(keccak256(abi.encodePacked(jobHash, _jobNonce(), block.number, block.timestamp)));\n      // divide by total number of pods, use modulus/remainder\n      uint256 pod = random % _operatorPods.length;\n      // identify the total number of available operators in pod\n      uint256 podSize = _operatorPods[pod].length;\n      // select a primary operator\n      uint256 operatorIndex = random % podSize;\n      // If operator index is 0, then it's open season! Anyone can execute this job. First come first serve.\n      // pop operator to ensure that they cannot be selected for any other job until this one completes\n      // decrease pod size to accomodate popped operator\n      _operatorTempStorage[_operatorTempStorageCounter] = _operatorPods[pod][operatorIndex];\n      _popOperator(pod, operatorIndex);\n      podSize--;\n      _operatorJobs[jobHash] = uint256(\n        ((pod + 1) << 248) |\n          (uint256(_operatorTempStorageCounter) << 216) |\n          (block.number << 176) |\n          (_RBH(random, podSize, 1) << 160) |\n          (_RBH(random, podSize, 2) << 144) |\n          (_RBH(random, podSize, 3) << 128) |\n          (_RBH(random, podSize, 4) << 112) |\n          (_RBH(random, podSize, 5) << 96) |\n          (block.timestamp << 16) |\n          0\n      ); // 80 next available bit position && so far 176 bits used with only 128 left\n      emit AvailableOperatorJob(jobHash, _payload);\n    }\n  }\n\n  function executeJob(bytes calldata _payload) external payable {\n    // we do our operator logic here\n    // we will also manage gas/value here\n    bytes32 hash = keccak256(_payload);\n    require(_operatorJobs[hash] > 0, \"HOLOGRAPH: invalid job\");\n    uint256 gasLimit = 0;\n    uint256 gasPrice = 0;\n    assembly {\n      gasLimit := calldataload(sub(add(_payload.offset, _payload.length), 0x40))\n      gasPrice := calldataload(sub(add(_payload.offset, _payload.length), 0x20))\n    }\n    OperatorJob memory job = getJobDetails(hash);\n    // first check if not default operator, or if zero address operator selected\n    if (job.operator != address(0)) {\n      uint256 pod = job.pod - 1;\n      if (job.operator != msg.sender) {\n        // we are at a point where operator failed to execute\n        // then check if time is still within limits\n        uint256 elapsedTime = block.timestamp - uint256(job.startTimestamp);\n        uint256 timeDifference = elapsedTime / job.blockTimes;\n        require(timeDifference > 0, \"HOLOGRAPH: operator has time\");\n        // at this point an operator failed to execute in given amount of time\n        // we need to check if gas price was a variable\n        require(gasPrice >= tx.gasprice, \"HOLOGRAPH: gas spike detected\");\n        // we now need to check if next operator is allowed\n        if (timeDifference < 6) {\n          uint256 podIndex = uint256(job.fallbackOperators[timeDifference - 1]);\n          // do a quick sanity check to make sure operator did not leave from index and does not result in revert\n          if (podIndex < _operatorPods[pod].length) {\n            // only do check if it is valid, otherwise allow anyone to do this\n            address fallbackOperator = _operatorPods[pod][podIndex];\n            require(fallbackOperator == msg.sender || fallbackOperator == address(0), \"HOLOGRAPH: invalid fallback\");\n          }\n        }\n        // reward the current operator\n        uint256 amount = _getBaseBondAmount(pod);\n        // this is where we slash default operator for missing the job\n        // for simplicity at this point, slashing pod base fee\n        _bondedAmounts[job.operator] -= amount;\n        // amount gets sent to msg.sender\n        _bondedAmounts[msg.sender] += amount;\n        uint256 currentBondAmount = _getCurrentBondAmount(pod);\n        // check leftover bonded amount\n        if (currentBondAmount >= _bondedAmounts[job.operator]) {\n          // if enough bond amount leftover, put operator back in\n          _operatorPods[pod].push(job.operator);\n          _bondedOperators[job.operator] = job.pod;\n        } else {\n          // return rest of bond amount to operator\n          // and do not re-instate the operator\n          // ... for now we just make that number disappear\n          _bondedAmounts[job.operator] = 0;\n        }\n      } else {\n        // put operator back in\n        _operatorPods[pod].push(msg.sender);\n        _bondedOperators[msg.sender] = job.pod;\n      }\n    }\n    //// we need to decide on a reward for operating here\n    // uint256 reward = ???;\n    //// operator gets sent the reward\n    // _bondedOperators[msg.sender] += reward;\n    // check that we have enough gas from operator to execute\n    require(gasleft() > gasLimit, \"HOLOGRAPH: not enough gas left\");\n    // now execute job\n    assembly {\n      calldatacopy(0, _payload.offset, sub(_payload.length, 0x40))\n      let result := call(gasLimit, sload(_bridgeSlot), callvalue(), 0, sub(_payload.length, 0x40), 0, 0)\n      if eq(result, 0) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n    delete _operatorJobs[hash];\n  }\n\n  function jobEstimator(bytes calldata _payload) external payable {\n    assembly {\n      switch eq(sload(_deadAddressSlot), caller())\n      case 0 {\n        mstore(0x80, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        mstore(0xa0, 0x0000002000000000000000000000000000000000000000000000000000000000)\n        mstore(0xc0, 0x000000484f4c4f47524150483a2074657374206f6e6c792063616c6c00000000)\n        mstore(0xe0, 0x0000000000000000000000000000000000000000000000000000000000000000)\n        revert(0x80, 0xc4)\n      }\n      let result := call(gas(), sload(_bridgeSlot), callvalue(), 0, sub(_payload.length, 0x40), 0, 0)\n      if eq(result, 0) {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    }\n  }\n\n  /*\n   * @dev Need to add an extra function to get LZ gas amount needed for their internal cross-chain message verification\n   */\n  function send(\n    uint256 gasLimit,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    bytes calldata _payload\n  ) external payable onlyBridge {\n    ILayerZeroEndpoint lZEndpoint;\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n    // need to recalculate the gas amounts for LZ to deliver message\n    lZEndpoint.send{value: msg.value}(\n      uint16(_interfaces().getChainId(ChainIdType.HOLOGRAPH, uint256(toChain), ChainIdType.LAYERZERO)),\n      abi.encodePacked(address(this)),\n      abi.encodePacked(_payload, gasLimit, gasPrice),\n      payable(msgSender),\n      address(this),\n      abi.encodePacked(uint16(1), uint256(52000 + (_payload.length * 25)))\n    );\n  }\n\n  /**\n   * @dev Internal nonce used for randomness.\n   *      We increment it on each return.\n   */\n  function _jobNonce() private returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := add(sload(_jobNonceSlot), 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_jobNonceSlot, jobNonce)\n    }\n  }\n\n  function _popOperator(uint256 pod, uint256 operatorIndex) private {\n    if (operatorIndex > 0) {\n      unchecked {\n        address operator = _operatorPods[pod][operatorIndex];\n        // remove operator pod reference\n        _bondedOperators[operator] = 0;\n        uint256 lastIndex = _operatorPods[pod].length - 1;\n        if (lastIndex != operatorIndex) {\n          _operatorPods[pod][operatorIndex] = _operatorPods[pod][lastIndex];\n        }\n        delete _operatorPods[pod][lastIndex];\n        _operatorPods[pod].pop();\n      }\n    }\n  }\n\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  function _holograph() private view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _interfaces() private view returns (IInterfaces interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  function _registry() private view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function _RBH(\n    uint256 random,\n    uint256 podSize,\n    uint256 n\n  ) private view returns (uint256) {\n    unchecked {\n      return (random + uint256(blockhash(block.number - n))) % podSize;\n    }\n  }\n\n  function getLZEndpoint() external view returns (address lZEndpoint) {\n    assembly {\n      lZEndpoint := sload(_lZEndpointSlot)\n    }\n  }\n\n  function setLZEndpoint(address lZEndpoint) external onlyAdmin {\n    assembly {\n      sstore(_lZEndpointSlot, lZEndpoint)\n    }\n  }\n\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n\n  function getJobDetails(bytes32 jobHash) public view returns (OperatorJob memory) {\n    uint256 packed = _operatorJobs[jobHash];\n    return\n      OperatorJob(\n        uint8(packed >> 248),\n        uint16(_blockTime),\n        _operatorTempStorage[uint32(packed >> 216)],\n        uint40(packed >> 176),\n        // TODO: move the bit-shifting around to have it be sequential\n        uint64(packed >> 16),\n        [\n          uint16(packed >> 160),\n          uint16(packed >> 144),\n          uint16(packed >> 128),\n          uint16(packed >> 112),\n          uint16(packed >> 96)\n        ]\n      );\n  }\n\n  function getPodOperators(uint256 pod) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    operators = _operatorPods[pod - 1];\n  }\n\n  function getPodOperators(\n    uint256 pod,\n    uint256 index,\n    uint256 length\n  ) external view returns (address[] memory operators) {\n    require(_operatorPods.length >= pod, \"HOLOGRAPH: pod does not exist\");\n    // decrease by one for easy code usage\n    pod--;\n    uint256 supply = _operatorPods[pod].length;\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    operators = new address[](length);\n    for (uint256 i = 0; i < length; i++) {\n      operators[i] = _operatorPods[pod][index + i];\n    }\n  }\n\n  function _getBaseBondAmount(uint256 pod) private view returns (uint256) {\n    return (_podMultiplier**pod) * _baseBondAmount;\n  }\n\n  function _getCurrentBondAmount(uint256 pod) private view returns (uint256) {\n    uint256 current = (_podMultiplier**pod) * _baseBondAmount;\n    if (_operatorPods.length < pod) {\n      return current;\n    }\n    uint256 threshold = _operatorThreshold / (2**pod);\n    uint256 position = _operatorPods[pod].length;\n    if (position > threshold) {\n      position -= threshold;\n      //       current += (current / _operatorThresholdDivisor) * position;\n      current += (current / _operatorThresholdDivisor) * (position / _operatorThresholdStep);\n    }\n    return current;\n  }\n\n  function getPodBondAmount(uint256 pod) external view returns (uint256 base, uint256 current) {\n    base = _getBaseBondAmount(pod - 1);\n    current = _getCurrentBondAmount(pod - 1);\n  }\n\n  function getBondedPod(address operator) external view returns (uint256 pod) {\n    return _bondedOperators[operator];\n  }\n\n  // add top-up option\n\n  function unbondUtilityToken(address operator, address recipient) external {\n    require(_bondedOperators[operator] != 0, \"HOLOGRAPH: operator not bonded\");\n    if (msg.sender != operator) {\n      require(_isContract(operator), \"HOLOGRAPH: operator not contract\");\n      // check that operator is ownable contract\n      require(Ownable(operator).isOwner(msg.sender), \"HOLOGRAPH: sender not owner\");\n    }\n    address utilityToken = IHolographRegistry(_registry()).getUtilityToken();\n    uint256 amount = _bondedAmounts[operator];\n    // here we subtract our fee for unbonding\n    require(ERC20Holograph(utilityToken).transfer(recipient, amount), \"HOLOGRAPH: token transfer failed\");\n    //// we need to track operator pod index for easy removal\n    // _popOperator(_bondedOperators[operator] - 1, operatorPodIndex);\n    _bondedOperators[operator] = 0;\n    _bondedAmounts[operator] = 0;\n  }\n\n  function bondUtilityToken(\n    address operator,\n    uint256 amount,\n    uint256 pod\n  ) external {\n    require(_bondedOperators[operator] == 0, \"HOLOGRAPH: operator is bonded\");\n    unchecked {\n      uint256 current = _getCurrentBondAmount(pod);\n      require(current <= amount, \"HOLOGRAPH: bond amount too small\");\n      // subtract difference and only keep bond amount\n      if (_operatorPods.length < pod) {\n        for (uint256 i = _operatorPods.length; i <= pod; i++) {\n          _operatorPods.push([address(0)]);\n        }\n      }\n      require(_operatorPods[pod - 1].length < type(uint16).max, \"HOLOGRAPH: too many operators\");\n      address utilityToken = IHolographRegistry(_registry()).getUtilityToken();\n      // we extract utility token amount from msg sender\n      require(\n        ERC20Holograph(utilityToken).transferFrom(msg.sender, address(this), amount),\n        \"HOLOGRAPH: token transfer failed\"\n      );\n      _operatorPods[pod - 1].push(operator);\n      _bondedOperators[operator] = pod;\n      _bondedAmounts[operator] = amount;\n    }\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n}\n"
    },
    "contracts/enum/ChainIdType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum ChainIdType {\n  UNDEFINED, //  0\n  EVM, //        1\n  HOLOGRAPH, //  2\n  LAYERZERO, //  3\n  HYPERLANE //   4\n}\n"
    },
    "contracts/interface/IHolographOperator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface IHolographOperator {\n  function lzReceive(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    uint64 _nonce,\n    bytes calldata _payload\n  ) external payable;\n\n  function executeJob(bytes calldata _payload) external payable;\n\n  function jobEstimator(bytes calldata _payload) external payable;\n\n  function send(\n    uint256 gas,\n    uint256 gasPrice,\n    uint32 toChain,\n    address msgSender,\n    bytes calldata _payload\n  ) external payable;\n\n  function getLZEndpoint() external view returns (address lZEndpoint);\n}\n"
    },
    "contracts/interface/IInterfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../enum/ChainIdType.sol\";\nimport \"../enum/InterfaceType.sol\";\nimport \"../enum/TokenUriType.sol\";\n\ninterface IInterfaces {\n  function contractURI(\n    string calldata name,\n    string calldata imageURL,\n    string calldata externalLink,\n    uint16 bps,\n    address contractAddress\n  ) external pure returns (string memory);\n\n  function supportsInterface(InterfaceType interfaceType, bytes4 interfaceId) external view returns (bool);\n\n  function updateInterface(\n    InterfaceType interfaceType,\n    bytes4 interfaceId,\n    bool supported\n  ) external;\n\n  function getChainId(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType\n  ) external view returns (uint256 toChainId);\n\n  function getUriPrepend(TokenUriType uriType) external view returns (string memory prepend);\n\n  function updateChainIdMap(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType,\n    uint256 toChainId\n  ) external;\n\n  function updateChainIdMaps(\n    ChainIdType[] calldata fromChainType,\n    uint256[] calldata fromChainId,\n    ChainIdType[] calldata toChainType,\n    uint256[] calldata toChainId\n  ) external;\n}\n"
    },
    "contracts/interface/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n  // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n  // @param _dstChainId - the destination chain identifier\n  // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n  // @param _payload - a custom bytes payload to send to the destination contract\n  // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n  // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n  // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n  function send(\n    uint16 _dstChainId,\n    bytes calldata _destination,\n    bytes calldata _payload,\n    address payable _refundAddress,\n    address _zroPaymentAddress,\n    bytes calldata _adapterParams\n  ) external payable;\n\n  // @notice used by the messaging library to publish verified payload\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source contract (as bytes) at the source chain\n  // @param _dstAddress - the address on destination chain\n  // @param _nonce - the unbound message ordering nonce\n  // @param _gasLimit - the gas limit for external contract execution\n  // @param _payload - verified payload to send to the destination contract\n  function receivePayload(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    address _dstAddress,\n    uint64 _nonce,\n    uint256 _gasLimit,\n    bytes calldata _payload\n  ) external;\n\n  // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n  // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n  // @param _srcAddress - the source chain contract address\n  function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n  // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n  // @param _dstChainId - the destination chain identifier\n  // @param _userApplication - the user app address on this EVM chain\n  // @param _payload - the custom message to send over LayerZero\n  // @param _payInZRO - if false, user app pays the protocol fee in native token\n  // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n  function estimateFees(\n    uint16 _dstChainId,\n    address _userApplication,\n    bytes calldata _payload,\n    bool _payInZRO,\n    bytes calldata _adapterParam\n  ) external view returns (uint256 nativeFee, uint256 zroFee);\n\n  // @notice get this Endpoint's immutable source identifier\n  function getChainId() external view returns (uint16);\n\n  // @notice the interface to retry failed message on this Endpoint destination\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  // @param _payload - the payload to be retried\n  function retryPayload(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    bytes calldata _payload\n  ) external;\n\n  // @notice query if any STORED payload (message blocking) at the endpoint.\n  // @param _srcChainId - the source chain identifier\n  // @param _srcAddress - the source chain contract address\n  function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n  // @notice query if the _libraryAddress is valid for sending msgs.\n  // @param _userApplication - the user app address on this EVM chain\n  function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n  // @notice query if the _libraryAddress is valid for receiving msgs.\n  // @param _userApplication - the user app address on this EVM chain\n  function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n  // @notice query if the non-reentrancy guard for send() is on\n  // @return true if the guard is on. false otherwise\n  function isSendingPayload() external view returns (bool);\n\n  // @notice query if the non-reentrancy guard for receive() is on\n  // @return true if the guard is on. false otherwise\n  function isReceivingPayload() external view returns (bool);\n\n  // @notice get the configuration of the LayerZero messaging library of the specified version\n  // @param _version - messaging library version\n  // @param _chainId - the chainId for the pending config change\n  // @param _userApplication - the contract address of the user application\n  // @param _configType - type of configuration. every messaging library has its own convention.\n  function getConfig(\n    uint16 _version,\n    uint16 _chainId,\n    address _userApplication,\n    uint256 _configType\n  ) external view returns (bytes memory);\n\n  // @notice get the send() LayerZero messaging library version\n  // @param _userApplication - the contract address of the user application\n  function getSendVersion(address _userApplication) external view returns (uint16);\n\n  // @notice get the lzReceive() LayerZero messaging library version\n  // @param _userApplication - the contract address of the user application\n  function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "contracts/interface/Ownable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface Ownable {\n  function owner() external view returns (address);\n\n  function isOwner() external view returns (bool);\n\n  function isOwner(address wallet) external view returns (bool);\n}\n"
    },
    "contracts/struct/OperatorJob.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nstruct OperatorJob {\n  uint8 pod;\n  uint16 blockTimes;\n  address operator;\n  uint40 startBlock;\n  uint64 startTimestamp;\n  uint16[5] fallbackOperators;\n}\n\n/*\n\nuint\t\tDigits\tMax value\n-----------------------------\nuint8\t\t3\t\t255\nuint16\t\t5\t\t65,535\nuint24\t\t8\t\t16,777,215\nuint32\t\t10\t\t4,294,967,295\nuint40\t\t13\t\t1,099,511,627,775\nuint48\t\t15\t\t281,474,976,710,655\nuint56\t\t17\t\t72,057,594,037,927,935\nuint64\t\t20\t\t18,446,744,073,709,551,615\nuint72\t\t22\t\t4,722,366,482,869,645,213,695\nuint80\t\t25\t\t1,208,925,819,614,629,174,706,175\nuint88\t\t27\t\t309,485,009,821,345,068,724,781,055\nuint96\t\t29\t\t79,228,162,514,264,337,593,543,950,335\n...\nuint128\t\t39\t\t340,282,366,920,938,463,463,374,607,431,768,211,455\n...\nuint256\t\t78\t\t115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,935\n\n*/\n"
    },
    "contracts/enum/InterfaceType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum InterfaceType {\n  UNDEFINED, // 0\n  ERC20, //     1\n  ERC721, //    2\n  ERC1155, //   3\n  PA1D //       4\n}\n"
    },
    "contracts/enum/TokenUriType.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum TokenUriType {\n  UNDEFINED, //   0\n  IPFS, //        1\n  HTTPS, //       2\n  ARWEAVE //      3\n}\n"
    },
    "contracts/interface/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface ILayerZeroUserApplicationConfig {\n  // @notice set the configuration of the LayerZero messaging library of the specified version\n  // @param _version - messaging library version\n  // @param _chainId - the chainId for the pending config change\n  // @param _configType - type of configuration. every messaging library has its own convention.\n  // @param _config - configuration in the bytes. can encode arbitrary content.\n  function setConfig(\n    uint16 _version,\n    uint16 _chainId,\n    uint256 _configType,\n    bytes calldata _config\n  ) external;\n\n  // @notice set the send() LayerZero messaging library version to _version\n  // @param _version - new messaging library version\n  function setSendVersion(uint16 _version) external;\n\n  // @notice set the lzReceive() LayerZero messaging library version to _version\n  // @param _version - new messaging library version\n  function setReceiveVersion(uint16 _version) external;\n\n  // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n  // @param _srcChainId - the chainId of the source chain\n  // @param _srcAddress - the contract address of the source contract at the source chain\n  function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "contracts/HolographERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\nimport \"./abstract/Owner.sol\";\n\nimport \"./enum/HolographERC721Event.sol\";\nimport \"./enum/InterfaceType.sol\";\n\nimport \"./interface/ERC165.sol\";\nimport \"./interface/ERC721.sol\";\nimport \"./interface/ERC721Holograph.sol\";\nimport \"./interface/ERC721Metadata.sol\";\nimport \"./interface/ERC721TokenReceiver.sol\";\nimport \"./interface/HolographableEnforcer.sol\";\nimport \"./interface/HolographedERC721.sol\";\nimport \"./interface/IHolograph.sol\";\nimport \"./interface/IHolographer.sol\";\nimport \"./interface/IHolographRegistry.sol\";\nimport \"./interface/IInitializable.sol\";\nimport \"./interface/IInterfaces.sol\";\nimport \"./interface/IPA1D.sol\";\nimport \"./interface/Ownable.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-721 Collection\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC721 is Admin, Owner, ERC721Holograph, Initializable {\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Collection name.\n   */\n  string private _name;\n\n  /**\n   * @dev Collection symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Collection royalty base points.\n   */\n  uint16 private _bps;\n\n  /**\n   * @dev Array of all token ids in collection.\n   */\n  uint256[] private _allTokens;\n\n  /**\n   * @dev Map of token id to array index of _ownedTokens.\n   */\n  mapping(uint256 => uint256) private _ownedTokensIndex;\n\n  /**\n   * @dev Token id to wallet (owner) address map.\n   */\n  mapping(uint256 => address) private _tokenOwner;\n\n  /**\n   * @dev 1-to-1 map of token id that was assigned an approved operator address.\n   */\n  mapping(uint256 => address) private _tokenApprovals;\n\n  /**\n   * @dev Map of total tokens owner by a specific address.\n   */\n  mapping(address => uint256) private _ownedTokensCount;\n\n  /**\n   * @dev Map of array of token ids owned by a specific address.\n   */\n  mapping(address => uint256[]) private _ownedTokens;\n\n  /**\n   * @notice Map of full operator approval for a particular address.\n   * @dev Usually utilised for supporting marketplace proxy wallets.\n   */\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  /**\n   * @dev Mapping from token id to position in the allTokens array.\n   */\n  mapping(uint256 => uint256) private _allTokensIndex;\n\n  /**\n   * @dev Mapping of all token ids that have been burned. This is to prevent re-minting of same token ids.\n   */\n  mapping(uint256 => bool) private _burnedTokens;\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n   */\n  constructor() {}\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC721: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC721: source only call\");\n    _;\n  }\n\n  /**\n   * @notice Gets a base64 encoded contract JSON file.\n   * @return string The URI.\n   */\n  function contractURI() external view returns (string memory) {\n    return IInterfaces(_interfaces()).contractURI(_name, \"\", \"\", _bps, address(this));\n  }\n\n  /**\n   * @notice Gets the name of the collection.\n   * @return string The collection name.\n   */\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @notice Shows the interfaces the contracts support\n   * @dev Must add new 4 byte interface Ids here to acknowledge support\n   * @param interfaceId ERC165 style 4 byte interfaceId.\n   * @return bool True if supported.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    IInterfaces interfaces = IInterfaces(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.ERC721, interfaceId) || // check global interfaces\n      interfaces.supportsInterface(InterfaceType.PA1D, interfaceId) || // check if royalties supports interface\n      erc165Contract.supportsInterface(interfaceId) // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Gets the collection's symbol.\n   * @return string The symbol.\n   */\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @notice Get's the URI of the token.\n   * @dev Defaults the the Arweave URI\n   * @return string The URI.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\n    require(_exists(tokenId), \"ERC721: token does not exist\");\n    ERC721Metadata sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    return sourceContract.tokenURI(tokenId);\n  }\n\n  /**\n   * @notice Get list of tokens owned by wallet.\n   * @param wallet The wallet address to get tokens for.\n   * @return uint256[] Returns an array of token ids owned by wallet.\n   */\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\n    return _ownedTokens[wallet];\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for tokens owned by wallet.\n   * @param wallet The wallet address to get tokens for.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return tokenIds uint256[] Returns a set length array of token ids owned by wallet.\n   */\n  function tokensOfOwner(\n    address wallet,\n    uint256 index,\n    uint256 length\n  ) external view returns (uint256[] memory tokenIds) {\n    uint256 supply = _ownedTokensCount[wallet];\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    tokenIds = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      tokenIds[i] = _ownedTokens[wallet][index + i];\n    }\n  }\n\n  /**\n   * @notice Adds a new address to the token's approval list.\n   * @dev Requires the sender to be in the approved addresses.\n   * @param to The address to approve.\n   * @param tokenId The affected token.\n   */\n  function approve(address to, uint256 tokenId) external payable {\n    address tokenOwner = _tokenOwner[tokenId];\n    require(to != tokenOwner, \"ERC721: cannot approve self\");\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeApprove)) {\n      require(SourceERC721().beforeApprove(tokenOwner, to, tokenId));\n    }\n    _tokenApprovals[tokenId] = to;\n    emit Approval(tokenOwner, to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterApprove)) {\n      require(SourceERC721().afterApprove(tokenOwner, to, tokenId));\n    }\n  }\n\n  /**\n   * @notice Burns the token.\n   * @dev The sender must be the owner or approved.\n   * @param tokenId The token to burn.\n   */\n  function burn(uint256 tokenId) external {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    address wallet = _tokenOwner[tokenId];\n    if (_isEventRegistered(HolographERC721Event.beforeBurn)) {\n      require(SourceERC721().beforeBurn(wallet, tokenId));\n    }\n    _burn(wallet, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterBurn)) {\n      require(SourceERC721().afterBurn(wallet, tokenId));\n    }\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    (address from, address to, uint256 tokenId, bytes memory data) = abi.decode(\n      payload,\n      (address, address, uint256, bytes)\n    );\n    require(!_exists(tokenId), \"ERC721: token already exists\");\n    delete _burnedTokens[tokenId];\n    _mint(to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.bridgeIn)) {\n      require(SourceERC721().bridgeIn(fromChain, from, to, tokenId, data), \"HOLOGRAPH: bridge in failed\");\n    }\n    return HolographableEnforcer.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    (address from, address to, uint256 tokenId) = abi.decode(payload, (address, address, uint256));\n    require(to != address(0), \"ERC721: zero address\");\n    require(_isApproved(sender, tokenId), \"ERC721: sender not approved\");\n    require(from == _tokenOwner[tokenId], \"ERC721: from is not owner\");\n    if (_isEventRegistered(HolographERC721Event.bridgeOut)) {\n      data = SourceERC721().bridgeOut(toChain, from, to, tokenId);\n    }\n    _burn(from, tokenId);\n    return (HolographableEnforcer.bridgeOut.selector, abi.encode(from, to, tokenId, data));\n  }\n\n  /**\n   * @notice Initializes the collection.\n   * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n   */\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    IInitializable sourceContract;\n    assembly {\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint16 contractBps,\n      uint256 eventConfig,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(data, (string, string, uint16, uint256, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _bps = contractBps;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == IInitializable.init.selector, \"ERC721: could not init source\");\n      (bool success, bytes memory returnData) = _royalties().delegatecall(\n        abi.encodeWithSignature(\"initPA1D(bytes)\", abi.encode(address(this), uint256(contractBps)))\n      );\n      bytes4 selector = abi.decode(returnData, (bytes4));\n      require(success && selector == IInitializable.init.selector, \"ERC721: coud not init PA1D\");\n    }\n\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   * @param from cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must exist and be owned by `from`.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external payable {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   * @param from cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must exist and be owned by `from`.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) public payable {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeSafeTransfer)) {\n      require(SourceERC721().beforeSafeTransfer(from, to, tokenId, data));\n    }\n    _transferFrom(from, to, tokenId);\n    if (_isContract(to)) {\n      require(\n        (ERC165(to).supportsInterface(ERC165.supportsInterface.selector) &&\n          ERC165(to).supportsInterface(ERC721TokenReceiver.onERC721Received.selector) &&\n          ERC721TokenReceiver(to).onERC721Received(address(this), from, tokenId, data) ==\n          ERC721TokenReceiver.onERC721Received.selector),\n        \"ERC721: onERC721Received fail\"\n      );\n    }\n    if (_isEventRegistered(HolographERC721Event.afterSafeTransfer)) {\n      require(SourceERC721().afterSafeTransfer(from, to, tokenId, data));\n    }\n  }\n\n  /**\n   * @notice Adds a new approved operator.\n   * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\n   * @param to The address to approve.\n   * @param approved Turn on or off approval status.\n   */\n  function setApprovalForAll(address to, bool approved) external {\n    require(to != msg.sender, \"ERC721: cannot approve self\");\n    if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n      require(SourceERC721().beforeApprovalAll(to, approved));\n    }\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n    if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n      require(SourceERC721().afterApprovalAll(to, approved));\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to burn a token.\n   *  Note: this is put in place to make sure that custom logic could be implemented for merging, gamification, etc.\n   *  Note: token cannot be burned if it's locked by bridge.\n   */\n  function sourceBurn(uint256 tokenId) external onlySource {\n    address wallet = _tokenOwner[tokenId];\n    _burn(wallet, tokenId);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a token.\n   */\n  function sourceMint(address to, uint224 tokenId) external onlySource {\n    // uint32 is reserved for chain id to be used\n    // we need to get current chain id, and prepend it to tokenId\n    // this will prevent possible tokenId overlap if minting simultaneously on multiple chains is possible\n    uint256 token = uint256(bytes32(abi.encodePacked(_chain(), tokenId)));\n    require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n    _mint(to, token);\n  }\n\n  /**\n   * @dev Allows source to get the prepend for their tokenIds.\n   */\n  function sourceGetChainPrepend() external view onlySource returns (uint256) {\n    return uint256(bytes32(abi.encodePacked(_chain(), uint224(0))));\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatch(address to, uint224[] calldata tokenIds) external onlySource {\n  //     require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < tokenIds.length; i++) {\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(to, token);\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatch(address[] calldata wallets, uint224[] calldata tokenIds) external onlySource {\n  //     require(wallets.length == tokenIds.length, \"ERC721: array length missmatch\");\n  //     require(tokenIds.length < 1000, \"ERC721: max batch size is 1000\");\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < tokenIds.length; i++) {\n  //       token = uint256(bytes32(abi.encodePacked(chain, tokenIds[i])));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(wallets[i], token);\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of tokens.\n   */\n  //   function sourceMintBatchIncremental(\n  //     address to,\n  //     uint224 startingTokenId,\n  //     uint256 length\n  //   ) external onlySource {\n  //     uint32 chain = _chain();\n  //     uint256 token;\n  //     for (uint256 i = 0; i < length; i++) {\n  //       token = uint256(bytes32(abi.encodePacked(chain, startingTokenId)));\n  //       require(!_burnedTokens[token], \"ERC721: can't mint burned token\");\n  //       _mint(to, token);\n  //       startingTokenId++;\n  //     }\n  //   }\n\n  /**\n   * @dev Allows for source smart contract to transfer a token.\n   *  Note: this is put in place to make sure that custom logic could be implemented for merging, gamification, etc.\n   *  Note: token cannot be transfered if it's locked by bridge.\n   */\n  function sourceTransfer(address to, uint256 tokenId) external onlySource {\n    address wallet = _tokenOwner[tokenId];\n    _transferFrom(wallet, to, tokenId);\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `msg.sender` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   */\n  function transfer(address to, uint256 tokenId) external payable {\n    transferFrom(msg.sender, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `from` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @param from  cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public payable {\n    transferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @notice Transfers `tokenId` token from `from` to `to`.\n   * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * @param from  cannot be the zero address.\n   * @param to cannot be the zero address.\n   * @param tokenId token must be owned by `from`.\n   * @param data additional data to pass.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory data\n  ) public payable {\n    require(_isApproved(msg.sender, tokenId), \"ERC721: not approved sender\");\n    if (_isEventRegistered(HolographERC721Event.beforeTransfer)) {\n      require(SourceERC721().beforeTransfer(from, to, tokenId, data));\n    }\n    _transferFrom(from, to, tokenId);\n    if (_isEventRegistered(HolographERC721Event.afterTransfer)) {\n      require(SourceERC721().afterTransfer(from, to, tokenId, data));\n    }\n  }\n\n  /**\n   * @notice Get total number of tokens owned by wallet.\n   * @dev Used to see total amount of tokens owned by a specific wallet.\n   * @param wallet Address for which to get token balance.\n   * @return uint256 Returns an integer, representing total amount of tokens held by address.\n   */\n  function balanceOf(address wallet) public view returns (uint256) {\n    require(wallet != address(0), \"ERC721: zero address\");\n    return _ownedTokensCount[wallet];\n  }\n\n  function burned(uint256 tokenId) public view returns (bool) {\n    return _burnedTokens[tokenId];\n  }\n\n  /**\n   * @notice Decimal places to have for totalSupply.\n   * @dev Since ERC721s are single, we use 0 as the decimal places to make sure a round number for totalSupply.\n   * @return uint256 Returns the number of decimal places to have for totalSupply.\n   */\n  function decimals() external pure returns (uint256) {\n    return 0;\n  }\n\n  function exists(uint256 tokenId) public view returns (bool) {\n    return _tokenOwner[tokenId] != address(0);\n  }\n\n  /**\n   * @notice Gets the approved address for the token.\n   * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\n   * @param tokenId Token id to get approved operator for.\n   * @return address Approved address for token.\n   */\n  function getApproved(uint256 tokenId) external view returns (address) {\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @notice Checks if the address is approved.\n   * @dev Includes references to OpenSea and Rarible marketplace proxies.\n   * @param wallet Address of the wallet.\n   * @param operator Address of the marketplace operator.\n   * @return bool True if approved.\n   */\n  function isApprovedForAll(address wallet, address operator) external view returns (bool) {\n    return _operatorApprovals[wallet][operator];\n  }\n\n  /**\n   * @notice Checks who the owner of a token is.\n   * @dev The token must exist.\n   * @param tokenId The token to look up.\n   * @return address Owner of the token.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address) {\n    address tokenOwner = _tokenOwner[tokenId];\n    require(tokenOwner != address(0), \"ERC721: token does not exist\");\n    return tokenOwner;\n  }\n\n  /**\n   * @notice Get token by index.\n   * @dev Used in conjunction with totalSupply function to iterate over all tokens in collection.\n   * @param index Index of token in array.\n   * @return uint256 Returns the token id of token located at that index.\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256) {\n    require(index < _allTokens.length, \"ERC721: index out of bounds\");\n    return _allTokens[index];\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for all tokens.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return tokenIds uint256[] Returns a set length array of token ids minted.\n   */\n  function tokens(uint256 index, uint256 length) external view returns (uint256[] memory tokenIds) {\n    uint256 supply = _allTokens.length;\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    tokenIds = new uint256[](length);\n    for (uint256 i = 0; i < length; i++) {\n      tokenIds[i] = _allTokens[index + i];\n    }\n  }\n\n  /**\n   * @notice Get token from wallet by index instead of token id.\n   * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\n   * @param wallet Specific address for which to get token for.\n   * @param index Index of token in array.\n   * @return uint256 Returns the token id of token located at that index in specified wallet.\n   */\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256) {\n    require(index < balanceOf(wallet), \"ERC721: index out of bounds\");\n    return _ownedTokens[wallet][index];\n  }\n\n  /**\n   * @notice Total amount of tokens in the collection.\n   * @dev Ignores burned tokens.\n   * @return uint256 Returns the total number of active (not burned) tokens.\n   */\n  function totalSupply() external view returns (uint256) {\n    return _allTokens.length;\n  }\n\n  /**\n   * @notice Empty function that is triggered by external contract on NFT transfer.\n   * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\n   * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\n   * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n   * @return bytes4 Returns the interfaceId of onERC721Received.\n   */\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4) {\n    require(_isContract(_operator), \"ERC721: operator not contract\");\n    if (_isEventRegistered(HolographERC721Event.beforeOnERC721Received)) {\n      require(SourceERC721().beforeOnERC721Received(_operator, _from, address(this), _tokenId, _data));\n    }\n    try ERC721Holograph(_operator).ownerOf(_tokenId) returns (address tokenOwner) {\n      require(tokenOwner == address(this), \"ERC721: contract not token owner\");\n    } catch {\n      revert(\"ERC721: token does not exist\");\n    }\n    if (_isEventRegistered(HolographERC721Event.afterOnERC721Received)) {\n      require(SourceERC721().afterOnERC721Received(_operator, _from, address(this), _tokenId, _data));\n    }\n    return ERC721TokenReceiver.onERC721Received.selector;\n  }\n\n  /**\n   * @dev Add a newly minted token into managed list of tokens.\n   * @param to Address of token owner for which to add the token.\n   * @param tokenId Id of token to add.\n   */\n  function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n    _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\n    _ownedTokensCount[to]++;\n    _ownedTokens[to].push(tokenId);\n    _allTokensIndex[tokenId] = _allTokens.length;\n    _allTokens.push(tokenId);\n  }\n\n  /**\n   * @notice Burns the token.\n   * @dev All validation needs to be done before calling this function.\n   * @param wallet Address of current token owner.\n   * @param tokenId The token to burn.\n   */\n  function _burn(address wallet, uint256 tokenId) private {\n    _clearApproval(tokenId);\n    _tokenOwner[tokenId] = address(0);\n    emit Transfer(wallet, address(0), tokenId);\n    _removeTokenFromOwnerEnumeration(wallet, tokenId);\n    _burnedTokens[tokenId] = true;\n  }\n\n  /**\n   * @notice Deletes a token from the approval list.\n   * @dev Removes from count.\n   * @param tokenId T.\n   */\n  function _clearApproval(uint256 tokenId) private {\n    delete _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @notice Mints an NFT.\n   * @dev Can to mint the token to the zero address and the token cannot already exist.\n   * @param to Address to mint to.\n   * @param tokenId The new token.\n   */\n  function _mint(address to, uint256 tokenId) private {\n    require(tokenId > 0, \"ERC721: token id cannot be zero\");\n    require(to != address(0), \"ERC721: minting to burn address\");\n    require(!_exists(tokenId), \"ERC721: token already exists\");\n    require(!_burnedTokens[tokenId], \"ERC721: token has been burned\");\n    _tokenOwner[tokenId] = to;\n    emit Transfer(address(0), to, tokenId);\n    _addTokenToOwnerEnumeration(to, tokenId);\n  }\n\n  function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n    uint256 lastTokenIndex = _allTokens.length - 1;\n    uint256 tokenIndex = _allTokensIndex[tokenId];\n    uint256 lastTokenId = _allTokens[lastTokenIndex];\n    _allTokens[tokenIndex] = lastTokenId;\n    _allTokensIndex[lastTokenId] = tokenIndex;\n    delete _allTokensIndex[tokenId];\n    delete _allTokens[lastTokenIndex];\n    _allTokens.pop();\n  }\n\n  /**\n   * @dev Remove a token from managed list of tokens.\n   * @param from Address of token owner for which to remove the token.\n   * @param tokenId Id of token to remove.\n   */\n  function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n    _removeTokenFromAllTokensEnumeration(tokenId);\n    _ownedTokensCount[from]--;\n    uint256 lastTokenIndex = _ownedTokensCount[from];\n    uint256 tokenIndex = _ownedTokensIndex[tokenId];\n    if (tokenIndex != lastTokenIndex) {\n      uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n      _ownedTokens[from][tokenIndex] = lastTokenId;\n      _ownedTokensIndex[lastTokenId] = tokenIndex;\n    }\n    if (lastTokenIndex == 0) {\n      delete _ownedTokens[from];\n    } else {\n      delete _ownedTokens[from][lastTokenIndex];\n      _ownedTokens[from].pop();\n    }\n  }\n\n  /**\n   * @dev Primary private function that handles the transfer/mint/burn functionality.\n   * @param from Address from where token is being transferred. Zero address means it is being minted.\n   * @param to Address to whom the token is being transferred. Zero address means it is being burned.\n   * @param tokenId Id of token that is being transferred/minted/burned.\n   */\n  function _transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) private {\n    require(_tokenOwner[tokenId] == from, \"ERC721: token not owned\");\n    require(to != address(0), \"ERC721: use burn instead\");\n    _clearApproval(tokenId);\n    _tokenOwner[tokenId] = to;\n    emit Transfer(from, to, tokenId);\n    _removeTokenFromOwnerEnumeration(from, tokenId);\n    _addTokenToOwnerEnumeration(to, tokenId);\n  }\n\n  function _chain() private view returns (uint32) {\n    uint32 currentChain = IHolograph(IHolographer(payable(address(this))).getHolograph()).getChainType();\n    if (currentChain != IHolographer(payable(address(this))).getOriginChain()) {\n      return currentChain;\n    }\n    return uint32(0);\n  }\n\n  /**\n   * @notice Checks if the token owner exists.\n   * @dev If the address is the zero address no owner exists.\n   * @param tokenId The affected token.\n   * @return bool True if it exists.\n   */\n  function _exists(uint256 tokenId) private view returns (bool) {\n    address tokenOwner = _tokenOwner[tokenId];\n    return tokenOwner != address(0);\n  }\n\n  /**\n   * @notice Checks if the address is an approved one.\n   * @dev Uses inlined checks for different usecases of approval.\n   * @param spender Address of the spender.\n   * @param tokenId The affected token.\n   * @return bool True if approved.\n   */\n  function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\n    require(_exists(tokenId), \"ERC721: token does not exist\");\n    address tokenOwner = _tokenOwner[tokenId];\n    return (spender == tokenOwner || _tokenApprovals[tokenId] == spender || _operatorApprovals[tokenOwner][spender]);\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Get the source smart contract as bridgeable interface.\n   */\n  function SourceERC721() private view returns (HolographedERC721 sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    Ownable ownableContract;\n    assembly {\n      ownableContract := sload(_sourceContractSlot)\n    }\n    return ownableContract.owner();\n  }\n\n  function _holograph() private view returns (IHolograph holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  /**\n   * @dev Get the bridge contract address.\n   */\n  function _royalties() private view returns (address) {\n    return\n      IHolographRegistry(_holograph().getRegistry()).getContractTypeAddress(\n        0x0000000000000000000000000000000000000000000000000000000050413144\n      );\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    // we check if royalties support the function, send there, otherwise revert to source\n    address _target;\n    if (IInterfaces(_interfaces()).supportsInterface(InterfaceType.PA1D, msg.sig)) {\n      _target = _royalties();\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    } else {\n      assembly {\n        calldatacopy(0, 0, calldatasize())\n        mstore(calldatasize(), caller())\n        let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n        returndatacopy(0, 0, returndatasize())\n        switch result\n        case 0 {\n          revert(0, returndatasize())\n        }\n        default {\n          return(0, returndatasize())\n        }\n      }\n    }\n  }\n\n  function _isEventRegistered(HolographERC721Event _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}\n"
    },
    "contracts/abstract/Owner.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract Owner {\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  /**\n   * @dev Event emitted when contract owner is changed.\n   */\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  constructor() {}\n\n  modifier onlyOwner() virtual {\n    require(msg.sender == getOwner(), \"HOLOGRAPH: owner only function\");\n    _;\n  }\n\n  function owner() public view virtual returns (address) {\n    return getOwner();\n  }\n\n  function getOwner() public view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function setOwner(address ownerAddress) public onlyOwner {\n    address previousOwner = getOwner();\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n    emit OwnershipTransferred(previousOwner, ownerAddress);\n  }\n\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0), \"HOLOGRAPH: zero address\");\n    assembly {\n      sstore(_ownerSlot, newOwner)\n    }\n  }\n\n  function ownerCall(address target, bytes calldata data) external payable onlyOwner {\n    assembly {\n      calldatacopy(0, data.offset, data.length)\n      let result := call(gas(), target, callvalue(), 0, data.length, 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/enum/HolographERC721Event.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum HolographERC721Event {\n  UNDEFINED, // 0\n  bridgeIn, //  1\n  bridgeOut, //  2\n  afterApprove, //  3\n  beforeApprove, //  4\n  afterApprovalAll, //  5\n  beforeApprovalAll, //  6\n  afterBurn, //  7\n  beforeBurn, //  8\n  afterMint, //  9\n  beforeMint, // 10\n  afterSafeTransfer, // 11\n  beforeSafeTransfer, // 12\n  afterTransfer, // 13\n  beforeTransfer, // 14\n  beforeOnERC721Received, // 15\n  afterOnERC721Received // 16\n}\n"
    },
    "contracts/interface/ERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\n/* is ERC165 */\ninterface ERC721 {\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n  ///  may be created and assigned without emitting Transfer. At the time of\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n  /// @dev This emits when the approved address for an NFT is changed or\n  ///  reaffirmed. The zero address indicates there is no approved address.\n  ///  When a Transfer event emits, this also indicates that the approved\n  ///  address for that NFT (if any) is reset to none.\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n  /// @dev This emits when an operator is enabled or disabled for an owner.\n  ///  The operator can manage all NFTs of the owner.\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  /// @notice Count all NFTs assigned to an owner\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\n  ///  function throws for queries about the zero address.\n  /// @param _owner An address for whom to query the balance\n  /// @return The number of NFTs owned by `_owner`, possibly zero\n  function balanceOf(address _owner) external view returns (uint256);\n\n  /// @notice Find the owner of an NFT\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\n  ///  about them do throw.\n  /// @param _tokenId The identifier for an NFT\n  /// @return The address of the owner of the NFT\n  function ownerOf(uint256 _tokenId) external view returns (address);\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n  ///  `onERC721Received` on `_to` and throws if the return value is not\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  /// @param data Additional data with no specified format, sent in call to `_to`\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata data\n  ) external payable;\n\n  /// @notice Transfers the ownership of an NFT from one address to another address\n  /// @dev This works identically to the other function with an extra data parameter,\n  ///  except this function just sets data to \"\".\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) external payable;\n\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n  ///  THEY MAY BE PERMANENTLY LOST\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\n  ///  `_tokenId` is not a valid NFT.\n  /// @param _from The current owner of the NFT\n  /// @param _to The new owner\n  /// @param _tokenId The NFT to transfer\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) external payable;\n\n  /// @notice Change or reaffirm the approved address for an NFT\n  /// @dev The zero address indicates there is no approved address.\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n  ///  operator of the current owner.\n  /// @param _approved The new approved NFT controller\n  /// @param _tokenId The NFT to approve\n  function approve(address _approved, uint256 _tokenId) external payable;\n\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\n  ///  all of `msg.sender`'s assets\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\n  ///  multiple operators per owner.\n  /// @param _operator Address to add to the set of authorized operators\n  /// @param _approved True if the operator is approved, false to revoke approval\n  function setApprovalForAll(address _operator, bool _approved) external;\n\n  /// @notice Get the approved address for a single NFT\n  /// @dev Throws if `_tokenId` is not a valid NFT.\n  /// @param _tokenId The NFT to find the approved address for\n  /// @return The approved address for this NFT, or the zero address if there is none\n  function getApproved(uint256 _tokenId) external view returns (address);\n\n  /// @notice Query if an address is an authorized operator for another address\n  /// @param _owner The address that owns the NFTs\n  /// @param _operator The address that acts on behalf of the owner\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n"
    },
    "contracts/interface/ERC721Holograph.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./CollectionURI.sol\";\nimport \"./ERC165.sol\";\nimport \"./ERC721.sol\";\nimport \"./ERC721Enumerable.sol\";\nimport \"./ERC721Metadata.sol\";\nimport \"./ERC721TokenReceiver.sol\";\nimport \"./HolographableEnforcer.sol\";\n\ninterface ERC721Holograph is\n  ERC165,\n  ERC721,\n  ERC721Enumerable,\n  ERC721Metadata,\n  ERC721TokenReceiver,\n  CollectionURI,\n  HolographableEnforcer\n{\n  function approve(address to, uint256 tokenId) external payable;\n\n  function burn(uint256 tokenId) external;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external payable;\n\n  function setApprovalForAll(address to, bool approved) external;\n\n  function sourceBurn(uint256 tokenId) external;\n\n  function sourceMint(address to, uint224 tokenId) external;\n\n  function sourceGetChainPrepend() external view returns (uint256);\n\n  function sourceTransfer(address to, uint256 tokenId) external;\n\n  function transfer(address to, uint256 tokenId) external payable;\n\n  function contractURI() external view returns (string memory);\n\n  function getApproved(uint256 tokenId) external view returns (address);\n\n  function isApprovedForAll(address wallet, address operator) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function burned(uint256 tokenId) external view returns (bool);\n\n  function decimals() external pure returns (uint256);\n\n  function exists(uint256 tokenId) external view returns (bool);\n\n  function ownerOf(uint256 tokenId) external view returns (address);\n\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n  function symbol() external view returns (string memory);\n\n  function tokenByIndex(uint256 index) external view returns (uint256);\n\n  function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256);\n\n  function tokensOfOwner(address wallet) external view returns (uint256[] memory);\n\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interface/ERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\n/* is ERC721 */\ninterface ERC721Metadata {\n  /// @notice A descriptive name for a collection of NFTs in this contract\n  function name() external view returns (string memory _name);\n\n  /// @notice An abbreviated name for NFTs in this contract\n  function symbol() external view returns (string memory _symbol);\n\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n  ///  Metadata JSON Schema\".\n  function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interface/ERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n  /// @notice Handle the receipt of an NFT\n  /// @dev The ERC721 smart contract calls this function on the recipient\n  ///  after a `transfer`. This function MAY throw to revert and reject the\n  ///  transfer. Return of other than the magic value MUST result in the\n  ///  transaction being reverted.\n  ///  Note: the contract address is always the message sender.\n  /// @param _operator The address which called `safeTransferFrom` function\n  /// @param _from The address which previously owned the token\n  /// @param _tokenId The NFT identifier which is being transferred\n  /// @param _data Additional data with no specified format\n  /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  ///  unless throwing\n  function onERC721Received(\n    address _operator,\n    address _from,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bytes4);\n}\n"
    },
    "contracts/interface/HolographedERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @title Holograph ERC-721 Non-Fungible Token Standard\n/// @dev See https://holograph.network/standard/ERC-721\n///  Note: the ERC-165 identifier for this interface is 0xFFFFFFFF.\ninterface HolographedERC721 {\n  // event id = 1\n  function bridgeIn(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 2\n  function bridgeOut(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _tokenId\n  ) external returns (bytes memory _data);\n\n  // event id = 3\n  function afterApprove(\n    address _owner,\n    address _to,\n    uint256 _tokenId\n  ) external returns (bool success);\n\n  // event id = 4\n  function beforeApprove(\n    address _owner,\n    address _to,\n    uint256 _tokenId\n  ) external returns (bool success);\n\n  // event id = 5\n  function afterApprovalAll(address _to, bool _approved) external returns (bool success);\n\n  // event id = 6\n  function beforeApprovalAll(address _to, bool _approved) external returns (bool success);\n\n  // event id = 7\n  function afterBurn(address _owner, uint256 _tokenId) external returns (bool success);\n\n  // event id = 8\n  function beforeBurn(address _owner, uint256 _tokenId) external returns (bool success);\n\n  // event id = 9\n  function afterMint(address _owner, uint256 _tokenId) external returns (bool success);\n\n  // event id = 10\n  function beforeMint(address _owner, uint256 _tokenId) external returns (bool success);\n\n  // event id = 11\n  function afterSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 12\n  function beforeSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 13\n  function afterTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 14\n  function beforeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 15\n  function afterOnERC721Received(\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 16\n  function beforeOnERC721Received(\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external returns (bool success);\n}\n"
    },
    "contracts/interface/IPA1D.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../library/Zora.sol\";\n\ninterface IPA1D {\n  function initPA1D(bytes memory data) external returns (bytes4);\n\n  function configurePayouts(address payable[] memory addresses, uint256[] memory bps) external;\n\n  function getPayoutInfo() external view returns (address payable[] memory addresses, uint256[] memory bps);\n\n  function getEthPayout() external;\n\n  function getTokenPayout(address tokenAddress) external;\n\n  function getTokensPayout(address[] memory tokenAddresses) external;\n\n  function supportsInterface(bytes4 interfaceId) external pure returns (bool);\n\n  function setRoyalties(\n    uint256 tokenId,\n    address payable receiver,\n    uint256 bp\n  ) external;\n\n  function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\n\n  function getFeeBps(uint256 tokenId) external view returns (uint256[] memory);\n\n  function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\n\n  function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n\n  function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\n\n  function tokenCreator(\n    address, /* contractAddress*/\n    uint256 tokenId\n  ) external view returns (address);\n\n  function calculateRoyaltyFee(\n    address, /* contractAddress */\n    uint256 tokenId,\n    uint256 amount\n  ) external view returns (uint256);\n\n  function marketContract() external view returns (address);\n\n  function tokenCreators(uint256 tokenId) external view returns (address);\n\n  function bidSharesForToken(uint256 tokenId) external view returns (Zora.BidShares memory bidShares);\n\n  function getStorageSlot(string calldata slot) external pure returns (bytes32);\n\n  function getTokenAddress(string memory tokenName) external view returns (address);\n}\n"
    },
    "contracts/interface/CollectionURI.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface CollectionURI {\n  function contractURI() external view returns (string memory);\n}\n"
    },
    "contracts/interface/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.13;\n\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\n/* is ERC721 */\ninterface ERC721Enumerable {\n  /// @notice Count NFTs tracked by this contract\n  /// @return A count of valid NFTs tracked by this contract, where each one of\n  ///  them has an assigned and queryable owner not equal to the zero address\n  function totalSupply() external view returns (uint256);\n\n  /// @notice Enumerate valid NFTs\n  /// @dev Throws if `_index` >= `totalSupply()`.\n  /// @param _index A counter less than `totalSupply()`\n  /// @return The token identifier for the `_index`th NFT,\n  ///  (sort order not specified)\n  function tokenByIndex(uint256 _index) external view returns (uint256);\n\n  /// @notice Enumerate NFTs assigned to an owner\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n  ///  `_owner` is the zero address, representing invalid NFTs.\n  /// @param _owner An address where we are interested in NFTs owned by them\n  /// @param _index A counter less than `balanceOf(_owner)`\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n  ///   (sort order not specified)\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/library/Zora.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Zora {\n  struct Decimal {\n    uint256 value;\n  }\n\n  struct BidShares {\n    // % of sale value that goes to the _previous_ owner of the nft\n    Decimal prevOwner;\n    // % of sale value that goes to the original creator of the nft\n    Decimal creator;\n    // % of sale value that goes to the seller (current owner) of the nft\n    Decimal owner;\n  }\n}\n"
    },
    "contracts/PA1D.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\nimport \"./abstract/Owner.sol\";\n\nimport \"./library/Zora.sol\";\n\nimport \"./interface/ERC20.sol\";\nimport \"./interface/IInitializable.sol\";\nimport \"./interface/IPA1D.sol\";\n\n/**\n * @title PA1D (CXIP)\n * @author CXIP-Labs\n * @notice A smart contract for providing royalty info, collecting royalties, and distributing it to configured payout wallets.\n * @dev This smart contract is not intended to be used directly. Apply it to any of your ERC721 or ERC1155 smart contracts through a delegatecall fallback.\n */\ncontract PA1D is Admin, Owner, Initializable {\n  bytes32 constant _defaultBpSlot = 0x3ab91e3c2ba71a57537d782545f8feb1d402b604f5e070fa6c3b911fc2f18f75;\n  bytes32 constant _defaultReceiverSlot = 0xfd430e1c7265cc31dbd9a10ce657e68878a41cfe179c80cd68c5edf961516848;\n  bytes32 constant _initializedPaidSlot = 0x33a44e907d5bf333e203bebc20bb8c91c00375213b80f466a908f3d50b337c6c;\n  bytes32 constant _payoutAddressesSlot = 0x700a541bc37f227b0d36d34e7b77cc0108bde768297c6f80f448f380387371df;\n  bytes32 constant _payoutBpsSlot = 0x7a62e8104cd2cc2ef6bd3a26bcb71428108fbe0e0ead6a5bfb8676781e2ed28d;\n\n  string constant _bpString = \"eip1967.Holograph.PA1D.bp\";\n  string constant _receiverString = \"eip1967.Holograph.PA1D.receiver\";\n  string constant _tokenAddressString = \"eip1967.Holograph.PA1D.tokenAddress\";\n\n  /**\n   * @notice Event emitted when setting/updating royalty info/fees. This is used by Rarible V1.\n   * @dev Emits event in order to comply with Rarible V1 royalty spec.\n   * @param tokenId Specific token id for which royalty info is being set, set as 0 for all tokens inside of the smart contract.\n   * @param recipients Address array of wallets that will receive tha royalties.\n   * @param bps Uint256 array of base points(percentages) that each wallet(specified in recipients) will receive from the royalty payouts. Make sure that all the base points add up to a total of 10000.\n   */\n  event SecondarySaleFees(uint256 tokenId, address[] recipients, uint256[] bps);\n\n  /**\n   * @dev Use this modifier to lock public functions that should not be accesible to non-owners.\n   */\n  modifier onlyOwner() override {\n    require(isOwner(), \"PA1D: caller not an owner\");\n    _;\n  }\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev Since the smart contract is being used inside of a fallback context, the constructor function is not being used.\n   */\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"PA1D: already initialized\");\n    assembly {\n      sstore(_adminSlot, caller())\n      sstore(_ownerSlot, caller())\n    }\n    (address receiver, uint256 bp) = abi.decode(data, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function initPA1D(bytes memory data) external returns (bytes4) {\n    uint256 initialized;\n    assembly {\n      initialized := sload(_initializedPaidSlot)\n    }\n    require(initialized == 0, \"PA1D: already initialized\");\n    (address receiver, uint256 bp) = abi.decode(data, (address, uint256));\n    setRoyalties(0, payable(receiver), bp);\n    initialized = 1;\n    assembly {\n      sstore(_initializedPaidSlot, initialized)\n    }\n    return IInitializable.init.selector;\n  }\n\n  /**\n   * @notice Check if message sender is a legitimate owner of the smart contract\n   * @dev We check owner, admin, and identity for a more comprehensive coverage.\n   * @return Returns true is message sender is an owner.\n   */\n  function isOwner() private view returns (bool) {\n    return (msg.sender == getOwner() ||\n      msg.sender == getAdmin() ||\n      msg.sender == Owner(address(this)).getOwner() ||\n      msg.sender == Admin(address(this)).getAdmin());\n  }\n\n  /**\n   * @dev Gets the default royalty payment receiver address from storage slot.\n   * @return receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _getDefaultReceiver() private view returns (address payable receiver) {\n    assembly {\n      receiver := sload(_defaultReceiverSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty payment receiver address to storage slot.\n   * @param receiver Wallet or smart contract that will receive the initial royalty payouts.\n   */\n  function _setDefaultReceiver(address receiver) private {\n    assembly {\n      sstore(_defaultReceiverSlot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the default royalty base points(percentage) from storage slot.\n   * @return bp Royalty base points(percentage) for royalty payouts.\n   */\n  function _getDefaultBp() private view returns (uint256 bp) {\n    assembly {\n      bp := sload(_defaultBpSlot)\n    }\n  }\n\n  /**\n   * @dev Sets the default royalty base points(percentage) to storage slot.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function _setDefaultBp(uint256 bp) private {\n    assembly {\n      sstore(_defaultBpSlot, bp)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty payment receiver address, for a particular token id, from storage slot.\n   * @return receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _getReceiver(uint256 tokenId) private view returns (address payable receiver) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      receiver := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty payment receiver address, for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the receiver for.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n   */\n  function _setReceiver(uint256 tokenId, address receiver) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_receiverString, tokenId))) - 1);\n    assembly {\n      sstore(slot, receiver)\n    }\n  }\n\n  /**\n   * @dev Gets the royalty base points(percentage), for a particular token id, from storage slot.\n   * @return bp Royalty base points(percentage) for the royalty payouts of a specific token id.\n   */\n  function _getBp(uint256 tokenId) private view returns (uint256 bp) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      bp := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the royalty base points(percentage), for a particular token id, to storage slot.\n   * @param tokenId Uint256 of the token id to set the base points for.\n   * @param bp Uint256 of royalty percentage, provided in base points format, for a particular token id.\n   */\n  function _setBp(uint256 tokenId, uint256 bp) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_bpString, tokenId))) - 1);\n    assembly {\n      sstore(slot, bp)\n    }\n  }\n\n  function _getPayoutAddresses() private view returns (address payable[] memory addresses) {\n    // The slot hash has been precomputed for gas optimizaion\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    addresses = new address payable[](length);\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      addresses[i] = value;\n    }\n  }\n\n  function _setPayoutAddresses(address payable[] memory addresses) private {\n    bytes32 slot = _payoutAddressesSlot;\n    uint256 length = addresses.length;\n    assembly {\n      sstore(slot, length)\n    }\n    address payable value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = addresses[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getPayoutBps() private view returns (uint256[] memory bps) {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length;\n    assembly {\n      length := sload(slot)\n    }\n    bps = new uint256[](length);\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      assembly {\n        value := sload(slot)\n      }\n      bps[i] = value;\n    }\n  }\n\n  function _setPayoutBps(uint256[] memory bps) private {\n    bytes32 slot = _payoutBpsSlot;\n    uint256 length = bps.length;\n    assembly {\n      sstore(slot, length)\n    }\n    uint256 value;\n    for (uint256 i = 0; i < length; i++) {\n      slot = keccak256(abi.encodePacked(i, slot));\n      value = bps[i];\n      assembly {\n        sstore(slot, value)\n      }\n    }\n  }\n\n  function _getTokenAddress(string memory tokenName) private view returns (address tokenAddress) {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      tokenAddress := sload(slot)\n    }\n  }\n\n  function _setTokenAddress(string memory tokenName, address tokenAddress) private {\n    bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(_tokenAddressString, tokenName))) - 1);\n    assembly {\n      sstore(slot, tokenAddress)\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers ETH to all payout recipients.\n   */\n  function _payoutEth() private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    // accommodating the 2300 gas stipend\n    // adding 1x for each item in array to accomodate rounding errors\n    uint256 gasCost = (23300 * length) + length;\n    uint256 balance = address(this).balance;\n    require(balance - gasCost > 10000, \"PA1D: Not enough ETH to transfer\");\n    balance = balance - gasCost;\n    uint256 sending;\n    // uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      addresses[i].transfer(sending);\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers tokens to all payout recipients.\n   * @param tokenAddress Smart contract address of ERC20 token.\n   */\n  function _payoutToken(address tokenAddress) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    uint256 length = addresses.length;\n    ERC20 erc20 = ERC20(tokenAddress);\n    uint256 balance = erc20.balanceOf(address(this));\n    require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n    uint256 sending;\n    //uint256 sent;\n    for (uint256 i = 0; i < length; i++) {\n      sending = ((bps[i] * balance) / 10000);\n      require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n      // sent = sent + sending;\n    }\n  }\n\n  /**\n   * @dev Internal function that transfers multiple tokens to all payout recipients.\n   * @dev Try to use _payoutToken and handle each token individually.\n   * @param tokenAddresses Array of smart contract addresses of ERC20 tokens.\n   */\n  function _payoutTokens(address[] memory tokenAddresses) private {\n    address payable[] memory addresses = _getPayoutAddresses();\n    uint256[] memory bps = _getPayoutBps();\n    ERC20 erc20;\n    uint256 balance;\n    uint256 sending;\n    for (uint256 t = 0; t < tokenAddresses.length; t++) {\n      erc20 = ERC20(tokenAddresses[t]);\n      balance = erc20.balanceOf(address(this));\n      require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n      // uint256 sent;\n      for (uint256 i = 0; i < addresses.length; i++) {\n        sending = ((bps[i] * balance) / 10000);\n        require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n        // sent = sent + sending;\n      }\n    }\n  }\n\n  /**\n   * @dev This function validates that the call is being made by an authorised wallet.\n   * @dev Will revert entire tranaction if it fails.\n   */\n  function _validatePayoutRequestor() private view {\n    if (!isOwner()) {\n      bool matched;\n      address payable[] memory addresses = _getPayoutAddresses();\n      address payable sender = payable(msg.sender);\n      for (uint256 i = 0; i < addresses.length; i++) {\n        if (addresses[i] == sender) {\n          matched = true;\n          break;\n        }\n      }\n      require(matched, \"PA1D: sender not authorized\");\n    }\n  }\n\n  /**\n   * @notice Set the wallets and percentages for royalty payouts.\n   * @dev Function can only we called by owner, admin, or identity wallet.\n   * @dev Addresses and bps arrays must be equal length. Bps values added together must equal 10000 exactly.\n   * @param addresses An array of all the addresses that will be receiving royalty payouts.\n   * @param bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function configurePayouts(address payable[] memory addresses, uint256[] memory bps) public onlyOwner {\n    require(addresses.length == bps.length, \"PA1D: missmatched array lenghts\");\n    uint256 totalBp;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      totalBp = totalBp + bps[i];\n    }\n    require(totalBp == 10000, \"PA1D: bps down't equal 10000\");\n    _setPayoutAddresses(addresses);\n    _setPayoutBps(bps);\n  }\n\n  /**\n   * @notice Show the wallets and percentages of payout recipients.\n   * @dev These are the recipients that will be getting royalty payouts.\n   * @return addresses An array of all the addresses that will be receiving royalty payouts.\n   * @return bps An array of the percentages that each address will receive from the royalty payouts.\n   */\n  function getPayoutInfo() public view returns (address payable[] memory addresses, uint256[] memory bps) {\n    addresses = _getPayoutAddresses();\n    bps = _getPayoutBps();\n  }\n\n  /**\n   * @notice Get payout of all ETH in smart contract.\n   * @dev Distribute all the ETH(minus gas fees) to payout recipients.\n   */\n  function getEthPayout() public {\n    _validatePayoutRequestor();\n    _payoutEth();\n  }\n\n  /**\n   * @notice Get payout for a specific token address. Token must have a positive balance!\n   * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n   * @param tokenAddress An address of the token for which to issue payouts for.\n   */\n  function getTokenPayout(address tokenAddress) public {\n    _validatePayoutRequestor();\n    _payoutToken(tokenAddress);\n  }\n\n  /**\n   * @notice Get payouts for tokens listed by address. Tokens must have a positive balance!\n   * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n   * @param tokenAddresses An address array of tokens to issue payouts for.\n   */\n  function getTokensPayout(address[] memory tokenAddresses) public {\n    _validatePayoutRequestor();\n    _payoutTokens(tokenAddresses);\n  }\n\n  /**\n   * @notice Set the royalty information for entire contract, or a specific token.\n   * @dev Take great care to not make this function accessible by other public functions in your overlying smart contract.\n   * @param tokenId Set a specific token id, or leave at 0 to set as default parameters.\n   * @param receiver Wallet or smart contract that will receive the royalty payouts.\n   * @param bp Uint256 of royalty percentage, provided in base points format.\n   */\n  function setRoyalties(\n    uint256 tokenId,\n    address payable receiver,\n    uint256 bp\n  ) public onlyOwner {\n    if (tokenId == 0) {\n      _setDefaultReceiver(receiver);\n      _setDefaultBp(bp);\n    } else {\n      _setReceiver(tokenId, receiver);\n      _setBp(tokenId, bp);\n    }\n    address[] memory receivers = new address[](1);\n    receivers[0] = address(receiver);\n    uint256[] memory bps = new uint256[](1);\n    bps[0] = bp;\n    emit SecondarySaleFees(tokenId, receivers, bps);\n  }\n\n  // IEIP2981\n  function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultReceiver(), (_getDefaultBp() * value) / 10000);\n    } else {\n      return (_getReceiver(tokenId), (_getBp(tokenId) * value) / 10000);\n    }\n  }\n\n  // Rarible V1\n  function getFeeBps(uint256 tokenId) public view returns (uint256[] memory) {\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      bps[0] = _getDefaultBp();\n    } else {\n      bps[0] = _getBp(tokenId);\n    }\n    return bps;\n  }\n\n  // Rarible V1\n  function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n    }\n    return receivers;\n  }\n\n  // Rarible V2(not being used since it creates a conflict with Manifold royalties)\n  // struct Part {\n  //     address payable account;\n  //     uint96 value;\n  // }\n\n  // function getRoyalties(uint256 tokenId) public view returns (Part[] memory) {\n  //     return royalties[id];\n  // }\n\n  // Manifold\n  function getRoyalties(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // Foundation\n  function getFees(uint256 tokenId) public view returns (address payable[] memory, uint256[] memory) {\n    address payable[] memory receivers = new address payable[](1);\n    uint256[] memory bps = new uint256[](1);\n    if (_getReceiver(tokenId) == address(0)) {\n      receivers[0] = _getDefaultReceiver();\n      bps[0] = _getDefaultBp();\n    } else {\n      receivers[0] = _getReceiver(tokenId);\n      bps[0] = _getBp(tokenId);\n    }\n    return (receivers, bps);\n  }\n\n  // SuperRare\n  // Hint taken from Manifold's RoyaltyEngine(https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol)\n  // To be quite honest, SuperRare is a closed marketplace. They're working on opening it up but looks like they want to use private smart contracts.\n  // We'll just leave this here for just in case they open the flood gates.\n  function tokenCreator(\n    address,\n    /* contractAddress*/\n    uint256 tokenId\n  ) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // SuperRare\n  function calculateRoyaltyFee(\n    address,\n    /* contractAddress */\n    uint256 tokenId,\n    uint256 amount\n  ) public view returns (uint256) {\n    if (_getReceiver(tokenId) == address(0)) {\n      return (_getDefaultBp() * amount) / 10000;\n    } else {\n      return (_getBp(tokenId) * amount) / 10000;\n    }\n  }\n\n  // Zora\n  // we indicate that this contract operates market functions\n  function marketContract() public view returns (address) {\n    return address(this);\n  }\n\n  // Zora\n  // we indicate that the receiver is the creator, to convince the smart contract to pay\n  function tokenCreators(uint256 tokenId) public view returns (address) {\n    address receiver = _getReceiver(tokenId);\n    if (receiver == address(0)) {\n      return _getDefaultReceiver();\n    }\n    return receiver;\n  }\n\n  // Zora\n  // we provide the percentage that needs to be paid out from the sale\n  function bidSharesForToken(uint256 tokenId) public view returns (Zora.BidShares memory bidShares) {\n    // this information is outside of the scope of our\n    bidShares.prevOwner.value = 0;\n    bidShares.owner.value = 0;\n    if (_getReceiver(tokenId) == address(0)) {\n      bidShares.creator.value = _getDefaultBp();\n    } else {\n      bidShares.creator.value = _getBp(tokenId);\n    }\n    return bidShares;\n  }\n\n  /**\n   * @notice Get the smart contract address of a token by common name.\n   * @dev Used only to identify really major/common tokens. Avoid using due to gas usages.\n   * @param tokenName The ticker symbol of the token. For example \"USDC\" or \"DAI\".\n   * @return The smart contract address of the token ticker symbol. Or zero address if not found.\n   */\n  function getTokenAddress(string memory tokenName) public view returns (address) {\n    return _getTokenAddress(tokenName);\n  }\n}\n"
    },
    "contracts/mock/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/EIP712.sol\";\nimport \"../abstract/NonReentrant.sol\";\n\nimport \"../interface/ERC20.sol\";\nimport \"../interface/ERC20Burnable.sol\";\nimport \"../interface/ERC20Holograph.sol\";\nimport \"../interface/ERC20Metadata.sol\";\nimport \"../interface/ERC20Permit.sol\";\nimport \"../interface/ERC20Receiver.sol\";\nimport \"../interface/ERC20Safer.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/ERC165.sol\";\n\nimport \"../library/Counters.sol\";\nimport \"../library/ECDSA.sol\";\n\n/**\n * @title Mock ERC20 Token\n * @author CXIP-Labs\n * @notice Used for imitating the likes of WETH and WMATIC tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract ERC20Mock is\n  ERC165,\n  ERC20,\n  ERC20Burnable,\n  ERC20Metadata,\n  ERC20Receiver,\n  ERC20Safer,\n  ERC20Permit,\n  NonReentrant,\n  EIP712\n{\n  using Counters for Counters.Counter;\n\n  bool private _works;\n\n  /**\n   * @dev Mapping of all the addresse's balances.\n   */\n  mapping(address => uint256) private _balances;\n\n  /**\n   * @dev Mapping of all authorized operators, and capped amounts.\n   */\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  /**\n   * @dev Total number of token in circulation.\n   */\n  uint256 private _totalSupply;\n\n  /**\n   * @dev Token name.\n   */\n  string private _name;\n\n  /**\n   * @dev Token ticker symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Token number of decimal places.\n   */\n  uint8 private _decimals;\n\n  /**\n   * @dev List of all supported ERC165 interfaces.\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev List of used up nonces. Used in the ERC20Permit interface functionality.\n   */\n  mapping(address => Counters.Counter) private _nonces;\n\n  /**\n   * @dev Constructor does not accept any parameters.\n   */\n  constructor(\n    string memory contractName,\n    string memory contractSymbol,\n    uint8 contractDecimals,\n    string memory domainSeperator,\n    string memory domainVersion\n  ) {\n    _works = true;\n    _name = contractName;\n    _symbol = contractSymbol;\n    _decimals = contractDecimals;\n\n    // ERC165\n    _supportedInterfaces[ERC165.supportsInterface.selector] = true;\n\n    // ERC20\n    _supportedInterfaces[ERC20.allowance.selector] = true;\n    _supportedInterfaces[ERC20.approve.selector] = true;\n    _supportedInterfaces[ERC20.balanceOf.selector] = true;\n    _supportedInterfaces[ERC20.totalSupply.selector] = true;\n    _supportedInterfaces[ERC20.transfer.selector] = true;\n    _supportedInterfaces[ERC20.transferFrom.selector] = true;\n    _supportedInterfaces[\n      ERC20.allowance.selector ^\n        ERC20.approve.selector ^\n        ERC20.balanceOf.selector ^\n        ERC20.totalSupply.selector ^\n        ERC20.transfer.selector ^\n        ERC20.transferFrom.selector\n    ] = true;\n\n    // ERC20Metadata\n    _supportedInterfaces[ERC20Metadata.name.selector] = true;\n    _supportedInterfaces[ERC20Metadata.symbol.selector] = true;\n    _supportedInterfaces[ERC20Metadata.decimals.selector] = true;\n    _supportedInterfaces[\n      ERC20Metadata.name.selector ^ ERC20Metadata.symbol.selector ^ ERC20Metadata.decimals.selector\n    ] = true;\n\n    // ERC20Burnable\n    _supportedInterfaces[ERC20Burnable.burn.selector] = true;\n    _supportedInterfaces[ERC20Burnable.burnFrom.selector] = true;\n    _supportedInterfaces[ERC20Burnable.burn.selector ^ ERC20Burnable.burnFrom.selector] = true;\n\n    // ERC20Safer\n    // bytes4(keccak256(abi.encodePacked('safeTransfer(address,uint256)'))) == 0x423f6cef\n    _supportedInterfaces[0x423f6cef] = true;\n    // bytes4(keccak256(abi.encodePacked('safeTransfer(address,uint256,bytes)'))) == 0xeb795549\n    _supportedInterfaces[0xeb795549] = true;\n    // bytes4(keccak256(abi.encodePacked('safeTransferFrom(address,address,uint256)'))) == 0x42842e0e\n    _supportedInterfaces[0x42842e0e] = true;\n    // bytes4(keccak256(abi.encodePacked('safeTransferFrom(address,address,uint256,bytes)'))) == 0xb88d4fde\n    _supportedInterfaces[0xb88d4fde] = true;\n    _supportedInterfaces[bytes4(0x423f6cef) ^ bytes4(0xeb795549) ^ bytes4(0x42842e0e) ^ bytes4(0xb88d4fde)] = true;\n\n    // ERC20Receiver\n    _supportedInterfaces[ERC20Receiver.onERC20Received.selector] = true;\n\n    // ERC20Permit\n    _supportedInterfaces[ERC20Permit.permit.selector] = true;\n    _supportedInterfaces[ERC20Permit.nonces.selector] = true;\n    _supportedInterfaces[ERC20Permit.DOMAIN_SEPARATOR.selector] = true;\n    _supportedInterfaces[\n      ERC20Permit.permit.selector ^ ERC20Permit.nonces.selector ^ ERC20Permit.DOMAIN_SEPARATOR.selector\n    ] = true;\n    _eip712_init(domainSeperator, domainVersion);\n  }\n\n  function toggleWorks(bool active) external {\n    _works = active;\n  }\n\n  function transferTokens(\n    address payable token,\n    address to,\n    uint256 amount\n  ) external {\n    ERC20(token).transfer(to, amount);\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Although EIP-165 is not required for ERC20 contracts, we still decided to implement it.\n   *\n   * This makes it easier for external smart contracts to easily identify a valid ERC20 token contract.\n   */\n  function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  function allowance(address account, address spender) public view returns (uint256) {\n    return _allowances[account][spender];\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function nonces(address account) public view returns (uint256) {\n    return _nonces[account].current();\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function burn(uint256 amount) public {\n    _burn(msg.sender, amount);\n  }\n\n  function burnFrom(address account, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[account][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n    unchecked {\n      _allowances[account][msg.sender] = currentAllowance - amount;\n    }\n    _burn(account, amount);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased below zero\");\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance - subtractedValue;\n    }\n    _approve(msg.sender, spender, newAllowance);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance + addedValue;\n    }\n    unchecked {\n      require(newAllowance >= currentAllowance, \"ERC20: increased above max value\");\n    }\n    _approve(msg.sender, spender, newAllowance);\n    return true;\n  }\n\n  function mint(address account, uint256 amount) external {\n    _mint(account, amount);\n  }\n\n  function onERC20Received(\n    address account,\n    address, /* sender*/\n    uint256 amount,\n    bytes calldata /* data*/\n  ) public returns (bytes4) {\n    assembly {\n      // used to drop \"change function to view\" compiler warning\n      sstore(0x17fb676f92438402d8ef92193dd096c59ee1f4ba1bb57f67f3e6d2eef8aeed5e, amount)\n    }\n    if (_works) {\n      require(_isContract(account), \"ERC20: operator not contract\");\n      try ERC20(account).balanceOf(address(this)) returns (uint256 balance) {\n        require(balance >= amount, \"ERC20: balance check failed\");\n      } catch {\n        revert(\"ERC20: failed getting balance\");\n      }\n      return ERC20Receiver.onERC20Received.selector;\n    } else {\n      return 0x00000000;\n    }\n  }\n\n  function permit(\n    address account,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    require(block.timestamp <= deadline, \"ERC20: expired deadline\");\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n    //  == 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\n    bytes32 structHash = keccak256(\n      abi.encode(\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\n        account,\n        spender,\n        amount,\n        _useNonce(account),\n        deadline\n      )\n    );\n    bytes32 hash = _hashTypedDataV4(structHash);\n    address signer = ECDSA.recover(hash, v, r, s);\n    require(signer == account, \"ERC20: invalid signature\");\n    _approve(account, spender, amount);\n  }\n\n  function safeTransfer(address recipient, uint256 amount) public returns (bool) {\n    return safeTransfer(recipient, amount, \"\");\n  }\n\n  function safeTransfer(\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    return true;\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) public returns (bool) {\n    return safeTransferFrom(account, recipient, amount, \"\");\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      uint256 currentAllowance = _allowances[account][msg.sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[account][msg.sender] = currentAllowance - amount;\n      }\n    }\n    _transfer(account, recipient, amount);\n    require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    return true;\n  }\n\n  function transfer(address recipient, uint256 amount) public returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      uint256 currentAllowance = _allowances[account][msg.sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[account][msg.sender] = currentAllowance - amount;\n      }\n    }\n    _transfer(account, recipient, amount);\n    return true;\n  }\n\n  function _approve(\n    address account,\n    address spender,\n    uint256 amount\n  ) internal {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(spender != address(0), \"ERC20: spender is zero address\");\n    _allowances[account][spender] = amount;\n    emit Approval(account, spender, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal {\n    require(account != address(0), \"ERC20: account is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _checkOnERC20Received(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) internal nonReentrant returns (bool) {\n    if (_isContract(recipient)) {\n      try ERC165(recipient).supportsInterface(0x01ffc9a7) returns (bool erc165support) {\n        require(erc165support, \"ERC20: no ERC165 support\");\n        // we have erc165 support\n        if (ERC165(recipient).supportsInterface(0x534f5876)) {\n          // we have eip-4524 support\n          try ERC20Receiver(recipient).onERC20Received(msg.sender, account, amount, data) returns (bytes4 retval) {\n            return retval == ERC20Receiver.onERC20Received.selector;\n          } catch (bytes memory reason) {\n            if (reason.length == 0) {\n              revert(\"ERC20: non ERC20Receiver\");\n            } else {\n              assembly {\n                revert(add(32, reason), mload(reason))\n              }\n            }\n          }\n        } else {\n          revert(\"ERC20: eip-4524 not supported\");\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC20: no ERC165 support\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @notice Mints tokens.\n   * @dev Mint a specific amount of tokens to a specific address.\n   * @param to Address to mint to.\n   * @param amount Amount of tokens to mint.\n   */\n  function _mint(address to, uint256 amount) internal {\n    require(to != address(0), \"ERC20: minting to burn address\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _transfer(\n    address account,\n    address recipient,\n    uint256 amount\n  ) internal {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(recipient != address(0), \"ERC20: recipient is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _balances[recipient] += amount;\n    emit Transfer(account, recipient, amount);\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   *\n   * _Available since v4.1._\n   */\n  function _useNonce(address account) internal returns (uint256 current) {\n    Counters.Counter storage nonce = _nonces[account];\n    current = nonce.current();\n    nonce.increment();\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n}\n"
    },
    "contracts/abstract/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity 0.8.13;\n\nimport \"../library/ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n  /* solhint-disable var-name-mixedcase */\n  // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n  // invalidate the cached domain separator if the chain id changes.\n  // WE CANNOT USE immutable VALUES SINCE IT BREAKS OUT CREATE2 COMPUTATIONS ON DEPLOYER SCRIPTS\n  // AFTER MAKING NECESARRY CHANGES, WE CAN ADD IT BACK IN\n  bytes32 private _CACHED_DOMAIN_SEPARATOR;\n  uint256 private _CACHED_CHAIN_ID;\n  address private _CACHED_THIS;\n\n  bytes32 private _HASHED_NAME;\n  bytes32 private _HASHED_VERSION;\n  bytes32 private _TYPE_HASH;\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n   *\n   * The meaning of `name` and `version` is specified in\n   * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n   *\n   * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n   * - `version`: the current major version of the signing domain.\n   *\n   * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n   * contract upgrade].\n   */\n  constructor() {}\n\n  function _eip712_init(string memory name, string memory version) internal {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n    _CACHED_CHAIN_ID = block.chainid;\n    _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n    _CACHED_THIS = address(this);\n    _TYPE_HASH = typeHash;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n   */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n      return _CACHED_DOMAIN_SEPARATOR;\n    } else {\n      return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n    }\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n   * function returns the hash of the fully encoded EIP712 message for this domain.\n   *\n   * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n   *\n   * ```solidity\n   * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n   *     keccak256(\"Mail(address to,string contents)\"),\n   *     mailTo,\n   *     keccak256(bytes(mailContents))\n   * )));\n   * address signer = ECDSA.recover(digest, signature);\n   * ```\n   */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n}\n"
    },
    "contracts/abstract/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nabstract contract NonReentrant {\n  bytes32 constant _reentrantSlot = 0x04b524dd539523930d3901481aa9455d7752b49add99e1647adb8b09a3137279;\n\n  constructor() {}\n\n  modifier nonReentrant() {\n    require(getStatus() != 2, \"HOLOGRAPH: reentrant call\");\n    setStatus(2);\n    _;\n    setStatus(1);\n  }\n\n  function getStatus() internal view returns (uint256 status) {\n    assembly {\n      status := sload(_reentrantSlot)\n    }\n  }\n\n  function setStatus(uint256 status) internal {\n    assembly {\n      sstore(_reentrantSlot, status)\n    }\n  }\n}\n"
    },
    "contracts/library/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity 0.8.13;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n    unchecked {\n      counter._value += 1;\n    }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n    unchecked {\n      counter._value = value - 1;\n    }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "contracts/library/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.13;\n\nimport \"./Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    } else if (error == RecoverError.InvalidSignatureV) {\n      revert(\"ECDSA: invalid signature 'v' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature` or error string. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   *\n   * Documentation for signature generation:\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    // Check the signature length\n    // - case 65: r,s,v signature (standard)\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else if (signature.length == 64) {\n      bytes32 r;\n      bytes32 vs;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      assembly {\n        r := mload(add(signature, 0x20))\n        vs := mload(add(signature, 0x40))\n      }\n      return tryRecover(hash, r, vs);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n   * `signature`. This address can then be used for verification purposes.\n   *\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n   * this function rejects them by requiring the `s` value to be in the lower\n   * half order, and the `v` value to be either 27 or 28.\n   *\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n   * verification to be secure: it is possible to craft signatures that\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n   * this is by receiving a hash of the original message (which may otherwise\n   * be too long), and then calling {toEthSignedMessageHash} on it.\n   */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n   *\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n   *\n   * _Available since v4.2._\n   */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   *\n   * _Available since v4.3._\n   */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n    if (v != 27 && v != 28) {\n      return (address(0), RecoverError.InvalidSignatureV);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n   * `r` and `s` signature fields separately.\n   */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n   * produces hash corresponding to the one signed with the\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n   * JSON-RPC method as part of EIP-191.\n   *\n   * See {recover}.\n   */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\n   * to the one signed with the\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n   * JSON-RPC method as part of EIP-712.\n   *\n   * See {recover}.\n   */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "contracts/library/Strings.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Strings {\n  function toHexString(address account) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(account)));\n  }\n\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = bytes16(\"0123456789abcdef\")[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  function toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint256 i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = char(hi);\n      s[2 * i + 1] = char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) {\n      return bytes1(uint8(b) + 0x30);\n    } else {\n      return bytes1(uint8(b) + 0x57);\n    }\n  }\n\n  function uint2str(uint256 _i) internal pure returns (string memory _uint256AsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n    uint256 j = _i;\n    uint256 len;\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n    bytes memory bstr = new bytes(len);\n    uint256 k = len;\n    while (_i != 0) {\n      k = k - 1;\n      uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n      bytes1 b1 = bytes1(temp);\n      bstr[k] = b1;\n      _i /= 10;\n    }\n    return string(bstr);\n  }\n\n  function toString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n}\n"
    },
    "contracts/Interfaces.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./enum/ChainIdType.sol\";\nimport \"./enum/InterfaceType.sol\";\nimport \"./enum/TokenUriType.sol\";\n\nimport \"./interface/CollectionURI.sol\";\nimport \"./interface/ERC20.sol\";\nimport \"./interface/ERC20Burnable.sol\";\nimport \"./interface/ERC20Metadata.sol\";\nimport \"./interface/ERC20Permit.sol\";\nimport \"./interface/ERC20Safer.sol\";\nimport \"./interface/ERC165.sol\";\nimport \"./interface/ERC721.sol\";\nimport \"./interface/ERC721Enumerable.sol\";\nimport \"./interface/ERC721Metadata.sol\";\nimport \"./interface/ERC721TokenReceiver.sol\";\nimport \"./interface/IInitializable.sol\";\nimport \"./interface/IPA1D.sol\";\n\nimport \"./library/Base64.sol\";\nimport \"./library/Strings.sol\";\n\ncontract Interfaces is Admin, Initializable {\n  mapping(InterfaceType => mapping(bytes4 => bool)) private _supportedInterfaces;\n  mapping(ChainIdType => mapping(uint256 => mapping(ChainIdType => uint256))) private _chainIdMap;\n  mapping(TokenUriType => string) private _prependURI;\n\n  constructor() {\n    _prependURI[TokenUriType.IPFS] = \"ipfs://\";\n    _prependURI[TokenUriType.HTTPS] = \"https://\";\n    _prependURI[TokenUriType.ARWEAVE] = \"ar://\";\n\n    // EVM -> HOLOGRAPH\n    // eth\n    _chainIdMap[ChainIdType.EVM][1][ChainIdType.HOLOGRAPH] = 1;\n    // bsc\n    _chainIdMap[ChainIdType.EVM][56][ChainIdType.HOLOGRAPH] = 2;\n    // avalanche\n    _chainIdMap[ChainIdType.EVM][43114][ChainIdType.HOLOGRAPH] = 3;\n    // polygon\n    _chainIdMap[ChainIdType.EVM][137][ChainIdType.HOLOGRAPH] = 4;\n    // arbitrum\n    _chainIdMap[ChainIdType.EVM][42161][ChainIdType.HOLOGRAPH] = 6;\n    // optimism\n    _chainIdMap[ChainIdType.EVM][10][ChainIdType.HOLOGRAPH] = 7;\n    // fantom\n    _chainIdMap[ChainIdType.EVM][250][ChainIdType.HOLOGRAPH] = 5;\n    // rinkeby\n    _chainIdMap[ChainIdType.EVM][4][ChainIdType.HOLOGRAPH] = 4000000001;\n    // goerli\n    _chainIdMap[ChainIdType.EVM][5][ChainIdType.HOLOGRAPH] = 4000000011;\n    // bsc testnet\n    _chainIdMap[ChainIdType.EVM][97][ChainIdType.HOLOGRAPH] = 4000000002;\n    // fuji\n    _chainIdMap[ChainIdType.EVM][43113][ChainIdType.HOLOGRAPH] = 4000000003;\n    // mumbai\n    _chainIdMap[ChainIdType.EVM][80001][ChainIdType.HOLOGRAPH] = 4000000004;\n    // arbitrum rinkeby\n    _chainIdMap[ChainIdType.EVM][421611][ChainIdType.HOLOGRAPH] = 4000000006;\n    // optimism kovan\n    _chainIdMap[ChainIdType.EVM][69][ChainIdType.HOLOGRAPH] = 4000000007;\n    // fantom testnet\n    _chainIdMap[ChainIdType.EVM][4002][ChainIdType.HOLOGRAPH] = 4000000005;\n    // local2\n    _chainIdMap[ChainIdType.EVM][1338][ChainIdType.HOLOGRAPH] = 4294967294;\n    // local\n    _chainIdMap[ChainIdType.EVM][1339][ChainIdType.HOLOGRAPH] = 4294967295;\n\n    // HOLOGRAPH -> EVM\n    // eth\n    _chainIdMap[ChainIdType.HOLOGRAPH][1][ChainIdType.EVM] = 1;\n    // bsc\n    _chainIdMap[ChainIdType.HOLOGRAPH][2][ChainIdType.EVM] = 56;\n    // avalanche\n    _chainIdMap[ChainIdType.HOLOGRAPH][3][ChainIdType.EVM] = 43114;\n    // polygon\n    _chainIdMap[ChainIdType.HOLOGRAPH][4][ChainIdType.EVM] = 137;\n    // arbitrum\n    _chainIdMap[ChainIdType.HOLOGRAPH][6][ChainIdType.EVM] = 42161;\n    // optimism\n    _chainIdMap[ChainIdType.HOLOGRAPH][7][ChainIdType.EVM] = 10;\n    // fantom\n    _chainIdMap[ChainIdType.HOLOGRAPH][5][ChainIdType.EVM] = 250;\n    // rinkeby\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000001][ChainIdType.EVM] = 4;\n    // goerli\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000011][ChainIdType.EVM] = 5;\n    // bsc testnet\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000002][ChainIdType.EVM] = 97;\n    // fuji\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000003][ChainIdType.EVM] = 43113;\n    // mumbai\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000004][ChainIdType.EVM] = 80001;\n    // arbitrum rinkeby\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000006][ChainIdType.EVM] = 421611;\n    // optimism kovan\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000007][ChainIdType.EVM] = 69;\n    // fantom testnet\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000005][ChainIdType.EVM] = 4002;\n    // local2\n    _chainIdMap[ChainIdType.HOLOGRAPH][4294967294][ChainIdType.EVM] = 1338;\n    // local\n    _chainIdMap[ChainIdType.HOLOGRAPH][4294967295][ChainIdType.EVM] = 1339;\n\n    // LAYERZERO -> HOLOGRAPH\n    // eth\n    _chainIdMap[ChainIdType.LAYERZERO][1][ChainIdType.HOLOGRAPH] = 1;\n    // bsc\n    _chainIdMap[ChainIdType.LAYERZERO][2][ChainIdType.HOLOGRAPH] = 2;\n    // avalanche\n    _chainIdMap[ChainIdType.LAYERZERO][6][ChainIdType.HOLOGRAPH] = 3;\n    // polygon\n    _chainIdMap[ChainIdType.LAYERZERO][9][ChainIdType.HOLOGRAPH] = 4;\n    // arbitrum\n    _chainIdMap[ChainIdType.LAYERZERO][10][ChainIdType.HOLOGRAPH] = 6;\n    // optimism\n    _chainIdMap[ChainIdType.LAYERZERO][11][ChainIdType.HOLOGRAPH] = 7;\n    // fantom\n    _chainIdMap[ChainIdType.LAYERZERO][12][ChainIdType.HOLOGRAPH] = 5;\n    // rinkeby\n    _chainIdMap[ChainIdType.LAYERZERO][10001][ChainIdType.HOLOGRAPH] = 4000000001;\n    // goerli\n    _chainIdMap[ChainIdType.LAYERZERO][10021][ChainIdType.HOLOGRAPH] = 4000000011;\n    // bsc testnet\n    _chainIdMap[ChainIdType.LAYERZERO][10002][ChainIdType.HOLOGRAPH] = 4000000002;\n    // fuji\n    _chainIdMap[ChainIdType.LAYERZERO][10006][ChainIdType.HOLOGRAPH] = 4000000003;\n    // mumbai\n    _chainIdMap[ChainIdType.LAYERZERO][10009][ChainIdType.HOLOGRAPH] = 4000000004;\n    // arbitrum rinkeby\n    _chainIdMap[ChainIdType.LAYERZERO][10010][ChainIdType.HOLOGRAPH] = 4000000006;\n    // optimism kovan\n    _chainIdMap[ChainIdType.LAYERZERO][10011][ChainIdType.HOLOGRAPH] = 4000000007;\n    // fantom testnet\n    _chainIdMap[ChainIdType.LAYERZERO][10012][ChainIdType.HOLOGRAPH] = 4000000005;\n    // local2\n    _chainIdMap[ChainIdType.LAYERZERO][65534][ChainIdType.HOLOGRAPH] = 4294967294;\n    // local\n    _chainIdMap[ChainIdType.LAYERZERO][65535][ChainIdType.HOLOGRAPH] = 4294967295;\n\n    // HOLOGRAPH -> LAYERZERO\n    // eth\n    _chainIdMap[ChainIdType.HOLOGRAPH][1][ChainIdType.LAYERZERO] = 1;\n    // bsc\n    _chainIdMap[ChainIdType.HOLOGRAPH][2][ChainIdType.LAYERZERO] = 2;\n    // avalanche\n    _chainIdMap[ChainIdType.HOLOGRAPH][3][ChainIdType.LAYERZERO] = 6;\n    // polygon\n    _chainIdMap[ChainIdType.HOLOGRAPH][4][ChainIdType.LAYERZERO] = 9;\n    // fantom\n    _chainIdMap[ChainIdType.HOLOGRAPH][5][ChainIdType.LAYERZERO] = 12;\n    // arbitrum\n    _chainIdMap[ChainIdType.HOLOGRAPH][6][ChainIdType.LAYERZERO] = 10;\n    // optimism\n    _chainIdMap[ChainIdType.HOLOGRAPH][7][ChainIdType.LAYERZERO] = 11;\n    // rinkeby\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000001][ChainIdType.LAYERZERO] = 10001;\n    // goerli\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000011][ChainIdType.LAYERZERO] = 10021;\n    // bsc testnet\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000002][ChainIdType.LAYERZERO] = 10002;\n    // fuji\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000003][ChainIdType.LAYERZERO] = 10006;\n    // mumbai\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000004][ChainIdType.LAYERZERO] = 10009;\n    // fantom testnet\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000005][ChainIdType.LAYERZERO] = 10012;\n    // arbitrum rinkeby\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000006][ChainIdType.LAYERZERO] = 10010;\n    // optimism kovan\n    _chainIdMap[ChainIdType.HOLOGRAPH][4000000007][ChainIdType.LAYERZERO] = 10011;\n    // local2\n    _chainIdMap[ChainIdType.HOLOGRAPH][4294967294][ChainIdType.LAYERZERO] = 65534;\n    // local\n    _chainIdMap[ChainIdType.HOLOGRAPH][4294967295][ChainIdType.LAYERZERO] = 65535;\n  }\n\n  function getUriPrepend(TokenUriType uriType) external view returns (string memory prepend) {\n    prepend = _prependURI[uriType];\n  }\n\n  function updateUriPrepend(TokenUriType uriType, string calldata prepend) external onlyAdmin {\n    _prependURI[uriType] = prepend;\n  }\n\n  function getChainId(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType\n  ) external view returns (uint256 toChainId) {\n    return _chainIdMap[fromChainType][fromChainId][toChainType];\n  }\n\n  function updateChainIdMap(\n    ChainIdType fromChainType,\n    uint256 fromChainId,\n    ChainIdType toChainType,\n    uint256 toChainId\n  ) external onlyAdmin {\n    _chainIdMap[fromChainType][fromChainId][toChainType] = toChainId;\n  }\n\n  function updateChainIdMaps(\n    ChainIdType[] calldata fromChainType,\n    uint256[] calldata fromChainId,\n    ChainIdType[] calldata toChainType,\n    uint256[] calldata toChainId\n  ) external onlyAdmin {\n    uint256 length = fromChainType.length;\n    for (uint256 i = 0; i < length; i++) {\n      _chainIdMap[fromChainType[i]][fromChainId[i]][toChainType[i]] = toChainId[i];\n    }\n  }\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    address contractAdmin = abi.decode(data, (address));\n    assembly {\n      sstore(_adminSlot, contractAdmin)\n    }\n\n    // ERC20\n\n    // ERC165\n    _supportedInterfaces[InterfaceType.ERC20][ERC165.supportsInterface.selector] = true;\n\n    // ERC20\n    _supportedInterfaces[InterfaceType.ERC20][ERC20.allowance.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20.approve.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20.balanceOf.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20.totalSupply.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20.transfer.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20.transferFrom.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][\n      ERC20.allowance.selector ^\n        ERC20.approve.selector ^\n        ERC20.balanceOf.selector ^\n        ERC20.totalSupply.selector ^\n        ERC20.transfer.selector ^\n        ERC20.transferFrom.selector\n    ] = true;\n\n    // ERC20Metadata\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Metadata.name.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Metadata.symbol.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Metadata.decimals.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][\n      ERC20Metadata.name.selector ^ ERC20Metadata.symbol.selector ^ ERC20Metadata.decimals.selector\n    ] = true;\n\n    // ERC20Burnable\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Burnable.burn.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Burnable.burnFrom.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Burnable.burn.selector ^ ERC20Burnable.burnFrom.selector] = true;\n\n    // ERC20Safer\n    _supportedInterfaces[InterfaceType.ERC20][0x423f6cef] = true;\n    _supportedInterfaces[InterfaceType.ERC20][0xeb795549] = true;\n    _supportedInterfaces[InterfaceType.ERC20][0x42842e0e] = true;\n    _supportedInterfaces[InterfaceType.ERC20][0xb88d4fde] = true;\n    _supportedInterfaces[InterfaceType.ERC20][\n      bytes4(0x423f6cef) ^\n        bytes4(0xeb795549) ^\n        bytes4(0x42842e0e) ^\n        bytes4(0xb88d4fde)\n    ] = true;\n\n    // ERC20Permit\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Permit.permit.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Permit.nonces.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][ERC20Permit.DOMAIN_SEPARATOR.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC20][\n      ERC20Permit.permit.selector ^ ERC20Permit.nonces.selector ^ ERC20Permit.DOMAIN_SEPARATOR.selector\n    ] = true;\n\n    // ERC721\n\n    // ERC165\n    _supportedInterfaces[InterfaceType.ERC721][ERC165.supportsInterface.selector] = true;\n\n    // ERC721\n    _supportedInterfaces[InterfaceType.ERC721][ERC721.balanceOf.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721.ownerOf.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][0x42842e0e] = true;\n    _supportedInterfaces[InterfaceType.ERC721][0xb88d4fde] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721.transferFrom.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721.approve.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721.setApprovalForAll.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721.getApproved.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721.isApprovedForAll.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][\n      ERC721.balanceOf.selector ^\n        ERC721.ownerOf.selector ^\n        0x42842e0e ^\n        0xb88d4fde ^\n        ERC721.transferFrom.selector ^\n        ERC721.approve.selector ^\n        ERC721.setApprovalForAll.selector ^\n        ERC721.getApproved.selector ^\n        ERC721.isApprovedForAll.selector\n    ] = true;\n\n    // ERC721Enumerable\n    _supportedInterfaces[InterfaceType.ERC721][ERC721Enumerable.totalSupply.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721Enumerable.tokenByIndex.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721Enumerable.tokenOfOwnerByIndex.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][\n      ERC721Enumerable.totalSupply.selector ^\n        ERC721Enumerable.tokenByIndex.selector ^\n        ERC721Enumerable.tokenOfOwnerByIndex.selector\n    ] = true;\n\n    // ERC721Metadata\n    _supportedInterfaces[InterfaceType.ERC721][ERC721Metadata.name.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721Metadata.symbol.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][ERC721Metadata.tokenURI.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][\n      ERC721Metadata.name.selector ^ ERC721Metadata.symbol.selector ^ ERC721Metadata.tokenURI.selector\n    ] = true;\n\n    // adding ERC20-like-Metadata support for Etherscan totalSupply fix\n    _supportedInterfaces[InterfaceType.ERC721][ERC20Metadata.decimals.selector] = true;\n    _supportedInterfaces[InterfaceType.ERC721][\n      ERC721Metadata.name.selector ^ ERC721Metadata.symbol.selector ^ ERC20Metadata.decimals.selector\n    ] = true;\n\n    // ERC721TokenReceiver\n    _supportedInterfaces[InterfaceType.ERC721][ERC721TokenReceiver.onERC721Received.selector] = true;\n\n    // CollectionURI\n    _supportedInterfaces[InterfaceType.ERC721][CollectionURI.contractURI.selector] = true;\n\n    // PA1D\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.initPA1D.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.configurePayouts.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getPayoutInfo.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getEthPayout.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getTokenPayout.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getTokensPayout.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.supportsInterface.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.setRoyalties.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.royaltyInfo.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getFeeBps.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getFeeRecipients.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getFeeBps.selector ^ IPA1D.getFeeRecipients.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getRoyalties.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getFees.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.tokenCreator.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.calculateRoyaltyFee.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.marketContract.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.tokenCreators.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.bidSharesForToken.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getStorageSlot.selector] = true;\n    _supportedInterfaces[InterfaceType.PA1D][IPA1D.getTokenAddress.selector] = true;\n\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function contractURI(\n    string calldata name,\n    string calldata imageURL,\n    string calldata externalLink,\n    uint16 bps,\n    address contractAddress\n  ) external pure returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\n          \"data:application/json;base64,\",\n          Base64.encode(\n            abi.encodePacked(\n              '{\"name\":\"',\n              name,\n              '\",\"description\":\"',\n              name,\n              '\",\"image\":\"',\n              imageURL,\n              '\",\"external_link\":\"',\n              externalLink,\n              '\",\"seller_fee_basis_points\":',\n              Strings.uint2str(bps),\n              ',\"fee_recipient\":\"0x',\n              Strings.toAsciiString(contractAddress),\n              '\"}'\n            )\n          )\n        )\n      );\n  }\n\n  function supportsInterface(InterfaceType interfaceType, bytes4 interfaceId) external view returns (bool) {\n    return _supportedInterfaces[interfaceType][interfaceId];\n  }\n\n  function updateInterface(\n    InterfaceType interfaceType,\n    bytes4 interfaceId,\n    bool supported\n  ) external onlyAdmin {\n    _supportedInterfaces[interfaceType][interfaceId] = supported;\n  }\n\n  function updateInterfaceBatch(\n    InterfaceType interfaceType,\n    bytes4[] calldata interfaceIds,\n    bool supported\n  ) external onlyAdmin {\n    for (uint256 i = 0; i < interfaceIds.length; i++) {\n      _supportedInterfaces[interfaceType][interfaceIds[i]] = supported;\n    }\n  }\n\n  receive() external payable {\n    revert();\n  }\n\n  fallback() external payable {\n    revert();\n  }\n}\n"
    },
    "contracts/library/Base64.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Base64 {\n  bytes private constant base64stdchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  bytes private constant base64urlchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n  function encode(string memory _str) internal pure returns (string memory) {\n    bytes memory _bs = bytes(_str);\n    return encode(_bs);\n  }\n\n  function encode(bytes memory _bs) internal pure returns (string memory) {\n    uint256 rem = _bs.length % 3;\n\n    uint256 res_length = ((_bs.length + 2) / 3) * 4 - ((3 - rem) % 3);\n    bytes memory res = new bytes(res_length);\n\n    uint256 i = 0;\n    uint256 j = 0;\n\n    for (; i + 3 <= _bs.length; i += 3) {\n      (res[j], res[j + 1], res[j + 2], res[j + 3]) = encode3(uint8(_bs[i]), uint8(_bs[i + 1]), uint8(_bs[i + 2]));\n\n      j += 4;\n    }\n\n    if (rem != 0) {\n      uint8 la0 = uint8(_bs[_bs.length - rem]);\n      uint8 la1 = 0;\n\n      if (rem == 2) {\n        la1 = uint8(_bs[_bs.length - 1]);\n      }\n\n      (\n        bytes1 b0,\n        bytes1 b1,\n        bytes1 b2, /* bytes1 b3*/\n\n      ) = encode3(la0, la1, 0);\n      res[j] = b0;\n      res[j + 1] = b1;\n      if (rem == 2) {\n        res[j + 2] = b2;\n      }\n    }\n\n    return string(res);\n  }\n\n  function encode3(\n    uint256 a0,\n    uint256 a1,\n    uint256 a2\n  )\n    private\n    pure\n    returns (\n      bytes1 b0,\n      bytes1 b1,\n      bytes1 b2,\n      bytes1 b3\n    )\n  {\n    uint256 n = (a0 << 16) | (a1 << 8) | a2;\n\n    uint256 c0 = (n >> 18) & 63;\n    uint256 c1 = (n >> 12) & 63;\n    uint256 c2 = (n >> 6) & 63;\n    uint256 c3 = (n) & 63;\n\n    b0 = base64urlchars[c0];\n    b1 = base64urlchars[c1];\n    b2 = base64urlchars[c2];\n    b3 = base64urlchars[c3];\n  }\n}\n"
    },
    "contracts/mock/MockERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/ERC721.sol\";\nimport \"../interface/ERC165.sol\";\nimport \"../interface/ERC721TokenReceiver.sol\";\n\ncontract MockERC721Receiver is ERC165, ERC721TokenReceiver {\n  bool private _works;\n\n  constructor() {\n    _works = true;\n  }\n\n  function toggleWorks(bool active) external {\n    _works = active;\n  }\n\n  function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n    if (interfaceID == 0x01ffc9a7 || interfaceID == 0x150b7a02) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function onERC721Received(\n    address, /*operator*/\n    address, /*from*/\n    uint256, /*tokenId*/\n    bytes calldata /*data*/\n  ) external view returns (bytes4) {\n    if (_works) {\n      return 0x150b7a02;\n    } else {\n      return 0x00000000;\n    }\n  }\n\n  function transferNFT(\n    address payable token,\n    uint256 tokenId,\n    address to\n  ) external {\n    ERC721(token).safeTransferFrom(address(this), to, tokenId);\n  }\n}\n"
    },
    "contracts/token/SampleERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/StrictERC721H.sol\";\n\nimport \"../interface/ERC721Holograph.sol\";\n\n/**\n * @title Sample ERC-721 Collection that is bridgeable via Holograph\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract SampleERC721 is StrictERC721H {\n  /**\n   * @dev Mapping of all token URIs.\n   */\n  mapping(uint256 => string) private _tokenURIs;\n\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /**\n   * @dev Temporary implementation to suppress compiler state mutability warnings.\n   */\n  bool private _dummy;\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n   */\n  constructor() {}\n\n  /**\n   * @notice Initializes the collection.\n   * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n   */\n  function init(bytes memory data) external override returns (bytes4) {\n    // do your own custom logic here\n    address contractOwner = abi.decode(data, (address));\n    _setOwner(contractOwner);\n    // run underlying initializer logic\n    return _init(data);\n  }\n\n  /**\n   * @notice Get's the URI of the token.\n   * @dev Defaults the the Arweave URI\n   * @return string The URI.\n   */\n  function tokenURI(uint256 _tokenId) external view onlyHolographer returns (string memory) {\n    return _tokenURIs[_tokenId];\n  }\n\n  /**\n   * @dev Sample mint where anyone can mint specific token, with a custom URI\n   */\n  function mint(\n    address to,\n    uint224 tokenId,\n    string calldata URI\n  ) external onlyHolographer onlyOwner {\n    ERC721Holograph H721 = ERC721Holograph(holographer());\n    if (tokenId == 0) {\n      _currentTokenId += 1;\n      while (H721.exists(uint256(_currentTokenId)) || H721.burned(uint256(_currentTokenId))) {\n        _currentTokenId += 1;\n      }\n      tokenId = _currentTokenId;\n    }\n    H721.sourceMint(to, tokenId);\n    uint256 id = H721.sourceGetChainPrepend() + uint256(tokenId);\n    _tokenURIs[id] = URI;\n  }\n\n  function bridgeIn(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external override onlyHolographer returns (bool) {\n    string memory URI = abi.decode(_data, (string));\n    _tokenURIs[_tokenId] = URI;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256 _tokenId\n  ) external override onlyHolographer returns (bytes memory _data) {\n    _dummy = false;\n    _data = abi.encode(_tokenURIs[_tokenId]);\n  }\n\n  function afterBurn(\n    address, /* _owner*/\n    uint256 _tokenId\n  ) external override onlyHolographer returns (bool) {\n    delete _tokenURIs[_tokenId];\n    return true;\n  }\n}\n"
    },
    "contracts/abstract/StrictERC721H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/HolographedERC721.sol\";\n\nimport \"./ERC721H.sol\";\n\nabstract contract StrictERC721H is ERC721H, HolographedERC721 {\n  /**\n   * @dev Dummy variable to prevent empty functions from making \"switch to pure\" warnings.\n   */\n  bool private _success;\n\n  function bridgeIn(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool) {\n    _success = true;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bytes memory _data) {\n    _success = true;\n    _data = abi.encode(holographer());\n  }\n\n  function afterApprove(\n    address, /* _owner*/\n    address, /* _to*/\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprove(\n    address, /* _owner*/\n    address, /* _to*/\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterApprovalAll(\n    address, /* _to*/\n    bool /* _approved*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprovalAll(\n    address, /* _to*/\n    bool /* _approved*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterBurn(\n    address, /* _owner*/\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeBurn(\n    address, /* _owner*/\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterMint(\n    address, /* _owner*/\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeMint(\n    address, /* _owner*/\n    uint256 /* _tokenId*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterSafeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeSafeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterOnERC721Received(\n    address, /* _operator*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeOnERC721Received(\n    address, /* _operator*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n}\n"
    },
    "contracts/abstract/ERC721H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC721H is Initializable {\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC721: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == holographer()) {\n      require(msgSender() == _getOwner(), \"ERC721: owner only function\");\n    } else {\n      require(msg.sender == _getOwner(), \"ERC721: owner only function\");\n    }\n    _;\n  }\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n   */\n  constructor() {}\n\n  /**\n   * @notice Initializes the collection.\n   * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n   */\n  function init(bytes memory data) external virtual override returns (bytes4) {\n    return _init(data);\n  }\n\n  function _init(\n    bytes memory /* data*/\n  ) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC721: already initialized\");\n    address _holographer = msg.sender;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n    }\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal pure returns (address sender) {\n    assembly {\n      sender := calldataload(sub(calldatasize(), 0x20))\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC721 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    if (msg.sender == holographer()) {\n      return msgSender() == _getOwner();\n    } else {\n      return msg.sender == _getOwner();\n    }\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  /**\n   * @dev Defined here to suppress compiler warnings\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "contracts/token/CxipERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/ERC721H.sol\";\n\nimport \"../enum/TokenUriType.sol\";\n\nimport \"../interface/ERC721Holograph.sol\";\nimport \"../interface/IInterfaces.sol\";\nimport \"../interface/IHolograph.sol\";\nimport \"../interface/IHolographer.sol\";\n\n/**\n * @title CXIP ERC-721 Collection that is bridgeable via Holograph\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract CxipERC721 is ERC721H {\n  /**\n   * @dev Internal reference used for minting incremental token ids.\n   */\n  uint224 private _currentTokenId;\n\n  /**\n   * @dev Enum of type of token URI to use globally for the entire contract.\n   */\n  TokenUriType private _uriType;\n\n  /**\n   * @dev Enum mapping of type of token URI to use for specific tokenId.\n   */\n  mapping(uint256 => TokenUriType) private _tokenUriType;\n\n  /**\n   * @dev Mapping of IPFS URIs for tokenIds.\n   */\n  mapping(uint256 => mapping(TokenUriType => string)) private _tokenURIs;\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n   */\n  constructor() {}\n\n  /**\n   * @notice Initializes the collection.\n   * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n   */\n  function init(bytes memory data) external override returns (bytes4) {\n    // we set this as default type since that's what Mint is currently using\n    _uriType = TokenUriType.IPFS;\n    address owner = abi.decode(data, (address));\n    _setOwner(owner);\n    // run underlying initializer logic\n    return _init(data);\n  }\n\n  /**\n   * @notice Get's the URI of the token.\n   * @return string The URI.\n   */\n  function tokenURI(uint256 _tokenId) external view onlyHolographer returns (string memory) {\n    TokenUriType uriType = _tokenUriType[_tokenId];\n    if (uriType == TokenUriType.UNDEFINED) {\n      uriType = _uriType;\n    }\n    return\n      string(\n        abi.encodePacked(\n          IInterfaces(IHolograph(IHolographer(holographer()).getHolograph()).getInterfaces()).getUriPrepend(uriType),\n          _tokenURIs[_tokenId][uriType]\n        )\n      );\n  }\n\n  function cxipMint(\n    uint224 tokenId,\n    TokenUriType uriType,\n    string calldata tokenUri\n  ) external onlyHolographer onlyOwner {\n    ERC721Holograph H721 = ERC721Holograph(holographer());\n    uint256 chainPrepend = H721.sourceGetChainPrepend();\n    if (tokenId == 0) {\n      _currentTokenId += 1;\n      while (\n        H721.exists(chainPrepend + uint256(_currentTokenId)) || H721.burned(chainPrepend + uint256(_currentTokenId))\n      ) {\n        _currentTokenId += 1;\n      }\n      tokenId = _currentTokenId;\n    }\n    H721.sourceMint(msgSender(), tokenId);\n    uint256 id = chainPrepend + uint256(tokenId);\n    if (uriType == TokenUriType.UNDEFINED) {\n      uriType = _uriType;\n    }\n    _tokenUriType[id] = uriType;\n    _tokenURIs[id][uriType] = tokenUri;\n  }\n\n  function bridgeIn(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256 _tokenId,\n    bytes calldata _data\n  ) external onlyHolographer returns (bool) {\n    (TokenUriType uriType, string memory tokenUri) = abi.decode(_data, (TokenUriType, string));\n    _tokenUriType[_tokenId] = uriType;\n    _tokenURIs[_tokenId][uriType] = tokenUri;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256 _tokenId\n  ) external view onlyHolographer returns (bytes memory _data) {\n    TokenUriType uriType = _tokenUriType[_tokenId];\n    if (uriType == TokenUriType.UNDEFINED) {\n      uriType = _uriType;\n    }\n    _data = abi.encode(uriType, _tokenURIs[_tokenId][uriType]);\n  }\n\n  function afterBurn(\n    address, /* _owner*/\n    uint256 _tokenId\n  ) external onlyHolographer returns (bool) {\n    TokenUriType uriType = _tokenUriType[_tokenId];\n    if (uriType == TokenUriType.UNDEFINED) {\n      uriType = _uriType;\n    }\n    delete _tokenURIs[_tokenId][uriType];\n    return true;\n  }\n}\n"
    },
    "contracts/HolographERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/EIP712.sol\";\nimport \"./abstract/Initializable.sol\";\nimport \"./abstract/NonReentrant.sol\";\nimport \"./abstract/Owner.sol\";\n\nimport \"./enum/HolographERC20Event.sol\";\nimport \"./enum/InterfaceType.sol\";\n\nimport \"./interface/ERC20.sol\";\nimport \"./interface/ERC20Burnable.sol\";\nimport \"./interface/ERC20Holograph.sol\";\nimport \"./interface/ERC20Metadata.sol\";\nimport \"./interface/ERC20Permit.sol\";\nimport \"./interface/ERC20Receiver.sol\";\nimport \"./interface/ERC20Safer.sol\";\nimport \"./interface/ERC165.sol\";\nimport \"./interface/HolographedERC20.sol\";\nimport \"./interface/IHolograph.sol\";\nimport \"./interface/IHolographer.sol\";\nimport \"./interface/IHolographRegistry.sol\";\nimport \"./interface/IInitializable.sol\";\nimport \"./interface/IInterfaces.sol\";\nimport \"./interface/Ownable.sol\";\n\nimport \"./library/Counters.sol\";\nimport \"./library/ECDSA.sol\";\n\n/**\n * @title Holograph Bridgeable ERC-20 Token\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing Holograph Bridgeable ERC20 Tokens.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract HolographERC20 is Admin, Owner, Initializable, NonReentrant, EIP712, ERC20Holograph {\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  bytes32 constant _sourceContractSlot = 0x27d542086d1e831d40b749e7f5509a626c3047a36d160781c40d5acc83e5b074;\n\n  using Counters for Counters.Counter;\n\n  /**\n   * @dev Configuration for events to trigger for source smart contract.\n   */\n  uint256 private _eventConfig;\n\n  /**\n   * @dev Mapping of all the addresse's balances.\n   */\n  mapping(address => uint256) private _balances;\n\n  /**\n   * @dev Mapping of all authorized operators, and capped amounts.\n   */\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  /**\n   * @dev Total number of token in circulation.\n   */\n  uint256 private _totalSupply;\n\n  /**\n   * @dev Token name.\n   */\n  string private _name;\n\n  /**\n   * @dev Token ticker symbol.\n   */\n  string private _symbol;\n\n  /**\n   * @dev Token number of decimal places.\n   */\n  uint8 private _decimals;\n\n  /**\n   * @dev List of used up nonces. Used in the ERC20Permit interface functionality.\n   */\n  mapping(address => Counters.Counter) private _nonces;\n\n  /**\n   * @dev Constructor does not accept any parameters.\n   */\n  constructor() {}\n\n  /**\n   * @notice Only allow calls from bridge smart contract.\n   */\n  modifier onlyBridge() {\n    require(msg.sender == _holograph().getBridge(), \"ERC20: bridge only call\");\n    _;\n  }\n\n  /**\n   * @notice Only allow calls from source smart contract.\n   */\n  modifier onlySource() {\n    address sourceContract;\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n    require(msg.sender == sourceContract, \"ERC20: source only call\");\n    _;\n  }\n\n  /**\n   * @notice Initializes the collection.\n   * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n   */\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"ERC20: already initialized\");\n    IInitializable sourceContract;\n    assembly {\n      sstore(_reentrantSlot, 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_ownerSlot, caller())\n      sourceContract := sload(_sourceContractSlot)\n    }\n    (\n      string memory contractName,\n      string memory contractSymbol,\n      uint8 contractDecimals,\n      uint256 eventConfig,\n      string memory domainSeperator,\n      string memory domainVersion,\n      bool skipInit,\n      bytes memory initCode\n    ) = abi.decode(data, (string, string, uint8, uint256, string, string, bool, bytes));\n    _name = contractName;\n    _symbol = contractSymbol;\n    _decimals = contractDecimals;\n    _eventConfig = eventConfig;\n    if (!skipInit) {\n      require(sourceContract.init(initCode) == IInitializable.init.selector, \"ERC20: could not init source\");\n    }\n    _setInitialized();\n    _eip712_init(domainSeperator, domainVersion);\n    return IInitializable.init.selector;\n  }\n\n  /**\n   * @dev Purposefully left empty, to prevent running out of gas errors when receiving native token payments.\n   */\n  receive() external payable {}\n\n  /**\n   * @notice Fallback to the source contract.\n   * @dev Any function call that is not covered here, will automatically be sent over to the source contract.\n   */\n  fallback() external payable {\n    assembly {\n      calldatacopy(0, 0, calldatasize())\n      mstore(calldatasize(), caller())\n      let result := call(gas(), sload(_sourceContractSlot), callvalue(), 0, add(calldatasize(), 32), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  function decimals() public view returns (uint8) {\n    return _decimals;\n  }\n\n  /**\n   * @dev Although EIP-165 is not required for ERC20 contracts, we still decided to implement it.\n   *\n   * This makes it easier for external smart contracts to easily identify a valid ERC20 token contract.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n    IInterfaces interfaces = IInterfaces(_interfaces());\n    ERC165 erc165Contract;\n    assembly {\n      erc165Contract := sload(_sourceContractSlot)\n    }\n    if (\n      interfaces.supportsInterface(InterfaceType.ERC20, interfaceId) || erc165Contract.supportsInterface(interfaceId) // check global interfaces // check if source supports interface\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function allowance(address account, address spender) public view returns (uint256) {\n    return _allowances[account][spender];\n  }\n\n  function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  function name() public view returns (string memory) {\n    return _name;\n  }\n\n  function nonces(address account) public view returns (uint256) {\n    return _nonces[account].current();\n  }\n\n  function symbol() public view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function approve(address spender, uint256 amount) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, amount));\n    }\n    _approve(msg.sender, spender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, amount));\n    }\n    return true;\n  }\n\n  function burn(uint256 amount) public {\n    if (_isEventRegistered(HolographERC20Event.beforeBurn)) {\n      require(SourceERC20().beforeBurn(msg.sender, amount));\n    }\n    _burn(msg.sender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterBurn)) {\n      require(SourceERC20().afterBurn(msg.sender, amount));\n    }\n  }\n\n  function burnFrom(address account, uint256 amount) public returns (bool) {\n    uint256 currentAllowance = _allowances[account][msg.sender];\n    require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n    unchecked {\n      _allowances[account][msg.sender] = currentAllowance - amount;\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeBurn)) {\n      require(SourceERC20().beforeBurn(account, amount));\n    }\n    _burn(account, amount);\n    if (_isEventRegistered(HolographERC20Event.afterBurn)) {\n      require(SourceERC20().afterBurn(account, amount));\n    }\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased below zero\");\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance - subtractedValue;\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, newAllowance));\n    }\n    _approve(msg.sender, spender, newAllowance);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, newAllowance));\n    }\n    return true;\n  }\n\n  function bridgeIn(uint32 fromChain, bytes calldata payload) external onlyBridge returns (bytes4) {\n    (address from, address to, uint256 amount, bytes memory data) = abi.decode(\n      payload,\n      (address, address, uint256, bytes)\n    );\n    _mint(to, amount);\n    if (_isEventRegistered(HolographERC20Event.bridgeIn)) {\n      require(SourceERC20().bridgeIn(fromChain, from, to, amount, data), \"HOLOGRAPH: bridge in failed\");\n    }\n    return HolographableEnforcer.bridgeIn.selector;\n  }\n\n  function bridgeOut(\n    uint32 toChain,\n    address sender,\n    bytes calldata payload\n  ) external onlyBridge returns (bytes4 selector, bytes memory data) {\n    (address from, address to, uint256 amount) = abi.decode(payload, (address, address, uint256));\n    if (sender != from) {\n      uint256 currentAllowance = _allowances[from][sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[from][sender] = currentAllowance - amount;\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.bridgeOut)) {\n      data = SourceERC20().bridgeOut(toChain, from, to, amount);\n    }\n    _burn(from, amount);\n    return (HolographableEnforcer.bridgeOut.selector, abi.encode(from, to, amount, data));\n  }\n\n  /**\n   * @dev Allows the bridge to mint tokens (used for hTokens only).\n   */\n  function holographBridgeMint(address to, uint256 amount) external onlyBridge returns (bytes4) {\n    _mint(to, amount);\n    return ERC20Holograph.holographBridgeMint.selector;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    uint256 newAllowance;\n    unchecked {\n      newAllowance = currentAllowance + addedValue;\n    }\n    unchecked {\n      require(newAllowance >= currentAllowance, \"ERC20: increased above max value\");\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(msg.sender, spender, newAllowance));\n    }\n    _approve(msg.sender, spender, newAllowance);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(msg.sender, spender, newAllowance));\n    }\n    return true;\n  }\n\n  function onERC20Received(\n    address account,\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) public returns (bytes4) {\n    require(_isContract(account), \"ERC20: operator not contract\");\n    if (_isEventRegistered(HolographERC20Event.beforeOnERC20Received)) {\n      require(SourceERC20().beforeOnERC20Received(account, sender, address(this), amount, data));\n    }\n    try ERC20(account).balanceOf(address(this)) returns (uint256 balance) {\n      require(balance >= amount, \"ERC20: balance check failed\");\n    } catch {\n      revert(\"ERC20: failed getting balance\");\n    }\n    if (_isEventRegistered(HolographERC20Event.afterOnERC20Received)) {\n      require(SourceERC20().afterOnERC20Received(account, sender, address(this), amount, data));\n    }\n    return ERC20Receiver.onERC20Received.selector;\n  }\n\n  function permit(\n    address account,\n    address spender,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    require(block.timestamp <= deadline, \"ERC20: expired deadline\");\n    bytes32 structHash = keccak256(\n      abi.encode(\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9,\n        account,\n        spender,\n        amount,\n        _useNonce(account),\n        deadline\n      )\n    );\n    bytes32 hash = _hashTypedDataV4(structHash);\n    address signer = ECDSA.recover(hash, v, r, s);\n    require(signer == account, \"ERC20: invalid signature\");\n    if (_isEventRegistered(HolographERC20Event.beforeApprove)) {\n      require(SourceERC20().beforeApprove(account, spender, amount));\n    }\n    _approve(account, spender, amount);\n    if (_isEventRegistered(HolographERC20Event.afterApprove)) {\n      require(SourceERC20().afterApprove(account, spender, amount));\n    }\n  }\n\n  function safeTransfer(address recipient, uint256 amount) public returns (bool) {\n    return safeTransfer(recipient, amount, \"\");\n  }\n\n  function safeTransfer(\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(SourceERC20().beforeSafeTransfer(msg.sender, recipient, amount, data));\n    }\n    _transfer(msg.sender, recipient, amount);\n    require(_checkOnERC20Received(msg.sender, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(SourceERC20().afterSafeTransfer(msg.sender, recipient, amount, data));\n    }\n    return true;\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) public returns (bool) {\n    return safeTransferFrom(account, recipient, amount, \"\");\n  }\n\n  function safeTransferFrom(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      uint256 currentAllowance = _allowances[account][msg.sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[account][msg.sender] = currentAllowance - amount;\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeSafeTransfer)) {\n      require(SourceERC20().beforeSafeTransfer(account, recipient, amount, data));\n    }\n    _transfer(account, recipient, amount);\n    require(_checkOnERC20Received(account, recipient, amount, data), \"ERC20: non ERC20Receiver\");\n    if (_isEventRegistered(HolographERC20Event.afterSafeTransfer)) {\n      require(SourceERC20().afterSafeTransfer(account, recipient, amount, data));\n    }\n    return true;\n  }\n\n  /**\n   * @dev Allows for source smart contract to burn tokens.\n   */\n  function sourceBurn(address from, uint256 amount) external onlySource {\n    _burn(from, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint tokens.\n   */\n  function sourceMint(address to, uint256 amount) external onlySource {\n    _mint(to, amount);\n  }\n\n  /**\n   * @dev Allows for source smart contract to mint a batch of token amounts.\n   */\n  function sourceMintBatch(address[] calldata wallets, uint256[] calldata amounts) external onlySource {\n    for (uint256 i = 0; i < wallets.length; i++) {\n      _mint(wallets[i], amounts[i]);\n    }\n  }\n\n  /**\n   * @dev Allows for source smart contract to transfer tokens.\n   */\n  function sourceTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) external onlySource {\n    _transfer(from, to, amount);\n  }\n\n  function transfer(address recipient, uint256 amount) public returns (bool) {\n    if (_isEventRegistered(HolographERC20Event.beforeTransfer)) {\n      require(SourceERC20().beforeTransfer(msg.sender, recipient, amount));\n    }\n    _transfer(msg.sender, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterTransfer)) {\n      require(SourceERC20().afterTransfer(msg.sender, recipient, amount));\n    }\n    return true;\n  }\n\n  function transferFrom(\n    address account,\n    address recipient,\n    uint256 amount\n  ) public returns (bool) {\n    if (account != msg.sender) {\n      uint256 currentAllowance = _allowances[account][msg.sender];\n      require(currentAllowance >= amount, \"ERC20: amount exceeds allowance\");\n      unchecked {\n        _allowances[account][msg.sender] = currentAllowance - amount;\n      }\n    }\n    if (_isEventRegistered(HolographERC20Event.beforeTransfer)) {\n      require(SourceERC20().beforeTransfer(account, recipient, amount));\n    }\n    _transfer(account, recipient, amount);\n    if (_isEventRegistered(HolographERC20Event.afterTransfer)) {\n      require(SourceERC20().afterTransfer(account, recipient, amount));\n    }\n    return true;\n  }\n\n  function _approve(\n    address account,\n    address spender,\n    uint256 amount\n  ) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(spender != address(0), \"ERC20: spender is zero address\");\n    _allowances[account][spender] = amount;\n    emit Approval(account, spender, amount);\n  }\n\n  function _burn(address account, uint256 amount) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _checkOnERC20Received(\n    address account,\n    address recipient,\n    uint256 amount,\n    bytes memory data\n  ) private nonReentrant returns (bool) {\n    if (_isContract(recipient)) {\n      try ERC165(recipient).supportsInterface(ERC165.supportsInterface.selector) returns (bool erc165support) {\n        require(erc165support, \"ERC20: no ERC165 support\");\n        // we have erc165 support\n        if (ERC165(recipient).supportsInterface(0x534f5876)) {\n          // we have eip-4524 support\n          try ERC20Receiver(recipient).onERC20Received(address(this), account, amount, data) returns (bytes4 retval) {\n            return retval == ERC20Receiver.onERC20Received.selector;\n          } catch (bytes memory reason) {\n            if (reason.length == 0) {\n              revert(\"ERC20: non ERC20Receiver\");\n            } else {\n              assembly {\n                revert(add(32, reason), mload(reason))\n              }\n            }\n          }\n        } else {\n          revert(\"ERC20: eip-4524 not supported\");\n        }\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC20: no ERC165 support\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @notice Mints tokens.\n   * @dev Mint a specific amount of tokens to a specific address.\n   * @param to Address to mint to.\n   * @param amount Amount of tokens to mint.\n   */\n  function _mint(address to, uint256 amount) private {\n    require(to != address(0), \"ERC20: minting to burn address\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n  }\n\n  function _transfer(\n    address account,\n    address recipient,\n    uint256 amount\n  ) private {\n    require(account != address(0), \"ERC20: account is zero address\");\n    require(recipient != address(0), \"ERC20: recipient is zero address\");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _balances[recipient] += amount;\n    emit Transfer(account, recipient, amount);\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n   *\n   * _Available since v4.1._\n   */\n  function _useNonce(address account) private returns (uint256 current) {\n    Counters.Counter storage nonce = _nonces[account];\n    current = nonce.current();\n    nonce.increment();\n  }\n\n  function _isContract(address contractAddress) private view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n\n  /**\n   * @dev Get the source smart contract as bridgeable interface.\n   */\n  function SourceERC20() private view returns (HolographedERC20 sourceContract) {\n    assembly {\n      sourceContract := sload(_sourceContractSlot)\n    }\n  }\n\n  /**\n   * @dev Get the interfaces contract address.\n   */\n  function _interfaces() private view returns (address) {\n    return _holograph().getInterfaces();\n  }\n\n  function owner() public view override returns (address) {\n    Ownable ownableContract;\n    assembly {\n      ownableContract := sload(_sourceContractSlot)\n    }\n    return ownableContract.owner();\n  }\n\n  function _holograph() private view returns (IHolograph holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _isEventRegistered(HolographERC20Event _eventName) private view returns (bool) {\n    return ((_eventConfig >> uint256(_eventName)) & uint256(1) == 1 ? true : false);\n  }\n}\n"
    },
    "contracts/enum/HolographERC20Event.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nenum HolographERC20Event {\n  UNDEFINED, // 0\n  bridgeIn, //  1\n  bridgeOut, //  2\n  afterApprove, //  3\n  beforeApprove, //  4\n  afterOnERC20Received, //  5\n  beforeOnERC20Received, //  6\n  afterBurn, //  7\n  beforeBurn, //  8\n  afterMint, //  9\n  beforeMint, // 10\n  afterSafeTransfer, // 11\n  beforeSafeTransfer, // 12\n  afterTransfer, // 13\n  beforeTransfer // 14\n}\n"
    },
    "contracts/HolographBridge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./enum/ChainIdType.sol\";\n\nimport \"./interface/ERC20Holograph.sol\";\nimport \"./interface/ERC721Holograph.sol\";\nimport \"./interface/HolographableEnforcer.sol\";\nimport \"./interface/IHolograph.sol\";\nimport \"./interface/IHolographBridge.sol\";\nimport \"./interface/IHolographFactory.sol\";\nimport \"./interface/IHolographOperator.sol\";\nimport \"./interface/IHolographRegistry.sol\";\nimport \"./interface/IInitializable.sol\";\nimport \"./interface/IInterfaces.sol\";\n\nimport \"./struct/DeploymentConfig.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @dev This smart contract contains the actual core bridging logic.\n */\ncontract HolographBridge is Admin, Initializable, IHolographBridge {\n  bytes32 constant _factorySlot = 0xa49f20855ba576e09d13c8041c8039fa655356ea27f6c40f1ec46a4301cd5b23;\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  bytes32 constant _interfacesSlot = 0xbd3084b8c09da87ad159c247a60e209784196be2530cecbbd8f337fdd1848827;\n  bytes32 constant _jobNonceSlot = 0x1cda64803f3b43503042e00863791e8d996666552d5855a78d53ee1dd4b3286d;\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev Constructor is left empty and only the admin address is set.\n   */\n  constructor() {}\n\n  modifier onlyBridge() {\n    require(msg.sender == address(this), \"HOLOGRAPH: bridge only call\");\n    _;\n  }\n\n  modifier onlyOperator() {\n    require(msg.sender == address(_operator()), \"HOLOGRAPH: operator only call\");\n    _;\n  }\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address factory, address holograph, address interfaces, address operator, address registry) = abi.decode(\n      data,\n      (address, address, address, address, address)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n\n      sstore(_factorySlot, factory)\n      sstore(_holographSlot, holograph)\n      sstore(_interfacesSlot, interfaces)\n      sstore(_operatorSlot, operator)\n      sstore(_registrySlot, registry)\n    }\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function bridgeInRequest(\n    uint256, /* nonce*/\n    uint32 fromChain,\n    address holographableContract,\n    address hToken,\n    address hTokenRecipient,\n    uint256 hTokenValue,\n    bytes calldata data\n  ) external onlyOperator {\n    require(\n      _registry().isHolographedContract(holographableContract) || address(_factory()) == holographableContract,\n      \"HOLOGRAPH: not holographed\"\n    );\n    bytes4 selector = HolographableEnforcer(holographableContract).bridgeIn(fromChain, data);\n    require(selector == HolographableEnforcer.bridgeIn.selector, \"HOLOGRAPH: bridge in failed\");\n    if (hTokenValue > 0) {\n      // provide operator with hToken value for executing bridge job\n      require(\n        ERC20Holograph(hToken).holographBridgeMint(hTokenRecipient, hTokenValue) ==\n          ERC20Holograph.holographBridgeMint.selector,\n        \"HOLOGRAPH: hToken mint failed\"\n      );\n    }\n  }\n\n  function bridgeOutRequest(\n    uint32 toChain,\n    address holographableContract,\n    uint256 gasLimit,\n    uint256 gasPrice,\n    bytes calldata data\n  ) external payable {\n    require(\n      _registry().isHolographedContract(holographableContract) || address(_factory()) == holographableContract,\n      \"HOLOGRAPH: not holographed\"\n    );\n    (bytes4 selector, bytes memory payload) = HolographableEnforcer(holographableContract).bridgeOut(\n      toChain,\n      msg.sender,\n      data\n    );\n    require(selector == HolographableEnforcer.bridgeOut.selector, \"HOLOGRAPH: bridge out failed\");\n    bytes memory encodedData = abi.encodeWithSelector(\n      HolographableEnforcer.bridgeIn.selector,\n      _jobNonce(),\n      _holograph().getChainType(),\n      holographableContract,\n      _registry().getHToken(_holograph().getChainType()),\n      address(0),\n      0,\n      payload\n    );\n    _operator().send{value: msg.value}(gasLimit, gasPrice, toChain, msg.sender, encodedData);\n  }\n\n  function getBridgeOutRequestPayload(\n    uint32 toChain,\n    address holographableContract,\n    bytes calldata data\n  ) external view returns (bytes memory samplePayload) {\n    require(\n      _registry().isHolographedContract(holographableContract) || address(_factory()) == holographableContract,\n      \"HOLOGRAPH: not holographed\"\n    );\n    (bool success, bytes memory rawResponse) = holographableContract.staticcall(\n      abi.encodeWithSelector(HolographableEnforcer.bridgeOut.selector, toChain, msg.sender, data)\n    );\n    require(success, \"HOLOGRAPH: bridge out failed\");\n    (bytes4 selector, bytes memory payload) = abi.decode(rawResponse, (bytes4, bytes));\n    uint256 jobNonce;\n    assembly {\n      jobNonce := sload(_jobNonceSlot)\n    }\n    require(selector == HolographableEnforcer.bridgeOut.selector, \"HOLOGRAPH: bridge out failed\");\n    bytes memory encodedData = abi.encodeWithSelector(\n      HolographableEnforcer.bridgeIn.selector,\n      jobNonce + 1,\n      _holograph().getChainType(),\n      holographableContract,\n      _registry().getHToken(_holograph().getChainType()),\n      address(0),\n      0,\n      payload\n    );\n    samplePayload = abi.encodePacked(encodedData, type(uint256).max, type(uint256).max);\n  }\n\n  /**\n   * @dev Internal nonce used for randomness.\n   *      We increment it on each return.\n   */\n  function _jobNonce() private returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := add(sload(_jobNonceSlot), 0x0000000000000000000000000000000000000000000000000000000000000001)\n      sstore(_jobNonceSlot, jobNonce)\n    }\n  }\n\n  function _factory() private view returns (IHolographFactory factory) {\n    assembly {\n      factory := sload(_factorySlot)\n    }\n  }\n\n  function _holograph() private view returns (IHolograph holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _interfaces() private view returns (IInterfaces interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  function _operator() private view returns (IHolographOperator operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  function _registry() private view returns (IHolographRegistry registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function getJobNonce() external view returns (uint256 jobNonce) {\n    assembly {\n      jobNonce := sload(_jobNonceSlot)\n    }\n  }\n\n  function getFactory() external view returns (address factory) {\n    assembly {\n      factory := sload(_factorySlot)\n    }\n  }\n\n  function setFactory(address factory) external onlyAdmin {\n    assembly {\n      sstore(_factorySlot, factory)\n    }\n  }\n\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  function getInterfaces() external view returns (address interfaces) {\n    assembly {\n      interfaces := sload(_interfacesSlot)\n    }\n  }\n\n  function setInterfaces(address interfaces) external onlyAdmin {\n    assembly {\n      sstore(_interfacesSlot, interfaces)\n    }\n  }\n\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n}\n"
    },
    "contracts/HolographTreasury.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/ERC20Holograph.sol\";\nimport \"./interface/ERC721Holograph.sol\";\nimport \"./interface/IHolograph.sol\";\nimport \"./interface/IHolographTreasury.sol\";\nimport \"./interface/IHolographFactory.sol\";\nimport \"./interface/IHolographOperator.sol\";\nimport \"./interface/IHolographRegistry.sol\";\nimport \"./interface/IInitializable.sol\";\n\nimport \"./struct/DeploymentConfig.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @dev This smart contract contains the actual core treasury logic.\n */\ncontract HolographTreasury is Admin, Initializable, IHolographTreasury {\n  bytes32 constant _bridgeSlot = 0xeb87cbb21687feb327e3d58c6c16d552231d12c7a0e8115042a4165fac8a77f9;\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  bytes32 constant _operatorSlot = 0x7caba557ad34138fa3b7e43fb574e0e6cc10481c3073e0dffbc560db81b5c60f;\n  bytes32 constant _registrySlot = 0xce8e75d5c5227ce29a4ee170160bb296e5dea6934b80a9bd723f7ef1e7c850e7;\n\n  /**\n   * @dev Constructor is left empty and only the admin address is set.\n   */\n  constructor() {}\n\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address bridge, address holograph, address operator, address registry) = abi.decode(\n      data,\n      (address, address, address, address)\n    );\n    assembly {\n      sstore(_adminSlot, origin())\n\n      sstore(_bridgeSlot, bridge)\n      sstore(_holographSlot, holograph)\n      sstore(_operatorSlot, operator)\n      sstore(_registrySlot, registry)\n    }\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  function _bridge() private view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  function _holograph() private view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function _operator() private view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  function _registry() private view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function getBridge() external view returns (address bridge) {\n    assembly {\n      bridge := sload(_bridgeSlot)\n    }\n  }\n\n  function setBridge(address bridge) external onlyAdmin {\n    assembly {\n      sstore(_bridgeSlot, bridge)\n    }\n  }\n\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  function getOperator() external view returns (address operator) {\n    assembly {\n      operator := sload(_operatorSlot)\n    }\n  }\n\n  function setOperator(address operator) external onlyAdmin {\n    assembly {\n      sstore(_operatorSlot, operator)\n    }\n  }\n\n  function getRegistry() external view returns (address registry) {\n    assembly {\n      registry := sload(_registrySlot)\n    }\n  }\n\n  function setRegistry(address registry) external onlyAdmin {\n    assembly {\n      sstore(_registrySlot, registry)\n    }\n  }\n}\n"
    },
    "contracts/interface/IHolographTreasury.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\ninterface IHolographTreasury {\n\n}\n"
    },
    "contracts/mock/LZEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/ILayerZeroReceiver.sol\";\nimport \"../interface/ILayerZeroEndpoint.sol\";\n\n/**\nmocking multi endpoint connection.\n- send() will short circuit to lzReceive() directly\n- no reentrancy guard. the real LayerZero endpoint on main net has a send and receive guard, respectively.\nif we run a ping-pong-like application, the recursive call might use all gas limit in the block.\n- not using any messaging library, hence all messaging library func, e.g. estimateFees, version, will not work\n*/\ncontract LZEndpointMock is ILayerZeroEndpoint {\n  mapping(address => address) public lzEndpointLookup;\n\n  uint16 public mockChainId;\n  address payable public mockOracle;\n  address payable public mockRelayer;\n  uint256 public mockBlockConfirmations;\n  uint16 public mockLibraryVersion;\n  uint256 public mockStaticNativeFee;\n  uint16 public mockLayerZeroVersion;\n  uint256 public nativeFee;\n  uint256 public zroFee;\n  bool nextMsgBLocked;\n\n  struct StoredPayload {\n    uint64 payloadLength;\n    address dstAddress;\n    bytes32 payloadHash;\n  }\n\n  struct QueuedPayload {\n    address dstAddress;\n    uint64 nonce;\n    bytes payload;\n  }\n\n  // inboundNonce = [srcChainId][srcAddress].\n  mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n  // outboundNonce = [dstChainId][srcAddress].\n  mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n  // storedPayload = [srcChainId][srcAddress]\n  mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n  // msgToDeliver = [srcChainId][srcAddress]\n  mapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\n\n  event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n  event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n  event PayloadStored(\n    uint16 srcChainId,\n    bytes srcAddress,\n    address dstAddress,\n    uint64 nonce,\n    bytes payload,\n    bytes reason\n  );\n\n  constructor(uint16 _chainId) {\n    mockStaticNativeFee = 42;\n    mockLayerZeroVersion = 1;\n    mockChainId = _chainId;\n  }\n\n  // mock helper to set the value returned by `estimateNativeFees`\n  function setEstimatedFees(uint256 _nativeFee, uint256 _zroFee) public {\n    nativeFee = _nativeFee;\n    zroFee = _zroFee;\n  }\n\n  function getChainId() external view override returns (uint16) {\n    return mockChainId;\n  }\n\n  function setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\n    lzEndpointLookup[destAddr] = lzEndpointAddr;\n  }\n\n  function send(\n    uint16 _chainId,\n    bytes calldata _destination,\n    bytes calldata _payload,\n    address payable, // _refundAddress\n    address, // _zroPaymentAddress\n    bytes memory _adapterParams\n  ) external payable override {\n    address destAddr = packedBytesToAddr(_destination);\n    address lzEndpoint = lzEndpointLookup[destAddr];\n\n    require(lzEndpoint != address(0), \"LayerZeroMock: destination LayerZero Endpoint not found\");\n\n    uint64 nonce;\n    {\n      nonce = ++outboundNonce[_chainId][msg.sender];\n    }\n\n    // Mock the relayer paying the dstNativeAddr the amount of extra native token\n    {\n      uint256 extraGas;\n      uint256 dstNative;\n      address dstNativeAddr;\n      assembly {\n        extraGas := mload(add(_adapterParams, 34))\n        dstNative := mload(add(_adapterParams, 66))\n        dstNativeAddr := mload(add(_adapterParams, 86))\n      }\n\n      // to simulate actually sending the ether, add a transfer call and ensure the LZEndpointMock contract has an ether balance\n    }\n\n    bytes memory bytesSourceUserApplicationAddr = addrToPackedBytes(address(msg.sender)); // cast this address to bytes\n\n    // not using the extra gas parameter because this is a single tx call, not split between different chains\n    // LZEndpointMock(lzEndpoint).receivePayload(mockChainId, bytesSourceUserApplicationAddr, destAddr, nonce, extraGas, _payload);\n    LZEndpointMock(lzEndpoint).receivePayload(\n      mockChainId,\n      bytesSourceUserApplicationAddr,\n      destAddr,\n      nonce,\n      0,\n      _payload\n    );\n  }\n\n  function receivePayload(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    address _dstAddress,\n    uint64 _nonce,\n    uint256, /*_gasLimit*/\n    bytes calldata _payload\n  ) external override {\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n\n    // assert and increment the nonce. no message shuffling\n    require(_nonce == ++inboundNonce[_srcChainId][_srcAddress], \"LayerZero: wrong nonce\");\n\n    // queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\n    if (sp.payloadHash != bytes32(0)) {\n      QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\n      QueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\n\n      // warning, might run into gas issues trying to forward through a bunch of queued msgs\n      // shift all the msgs over so we can treat this like a fifo via array.pop()\n      if (msgs.length > 0) {\n        // extend the array\n        msgs.push(newMsg);\n\n        // shift all the indexes up for pop()\n        for (uint256 i = 0; i < msgs.length - 1; i++) {\n          msgs[i + 1] = msgs[i];\n        }\n\n        // put the newMsg at the bottom of the stack\n        msgs[0] = newMsg;\n      } else {\n        msgs.push(newMsg);\n      }\n    } else if (nextMsgBLocked) {\n      storedPayload[_srcChainId][_srcAddress] = StoredPayload(\n        uint64(_payload.length),\n        _dstAddress,\n        keccak256(_payload)\n      );\n      emit PayloadStored(_srcChainId, _srcAddress, _dstAddress, _nonce, _payload, bytes(\"\"));\n      // ensure the next msgs that go through are no longer blocked\n      nextMsgBLocked = false;\n    } else {\n      // we ignore the gas limit because this call is made in one tx due to being \"same chain\"\n      // ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\n      ILayerZeroReceiver(_dstAddress).lzReceive(_srcChainId, _srcAddress, _nonce, _payload); // invoke lzReceive\n    }\n  }\n\n  // used to simulate messages received get stored as a payload\n  function blockNextMsg() external {\n    nextMsgBLocked = true;\n  }\n\n  function getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint256) {\n    return msgsToDeliver[_srcChainId][_srcAddress].length;\n  }\n\n  // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n  // @param _dstChainId - the destination chain identifier\n  // @param _userApplication - the user app address on this EVM chain\n  // @param _payload - the custom message to send over LayerZero\n  // @param _payInZRO - if false, user app pays the protocol fee in native token\n  // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n  function estimateFees(\n    uint16,\n    address,\n    bytes memory,\n    bool,\n    bytes memory\n  ) external view override returns (uint256 _nativeFee, uint256 _zroFee) {\n    _nativeFee = nativeFee;\n    _zroFee = zroFee;\n  }\n\n  // give 20 bytes, return the decoded address\n  function packedBytesToAddr(bytes calldata _b) public pure returns (address) {\n    address addr;\n    assembly {\n      let ptr := mload(0x40)\n      calldatacopy(ptr, sub(_b.offset, 2), add(_b.length, 2))\n      addr := mload(sub(ptr, 10))\n    }\n    return addr;\n  }\n\n  // given an address, return the 20 bytes\n  function addrToPackedBytes(address _a) public pure returns (bytes memory) {\n    bytes memory data = abi.encodePacked(_a);\n    return data;\n  }\n\n  function setConfig(\n    uint16, /*_version*/\n    uint16, /*_chainId*/\n    uint256, /*_configType*/\n    bytes memory /*_config*/\n  ) external override {}\n\n  function getConfig(\n    uint16, /*_version*/\n    uint16, /*_chainId*/\n    address, /*_ua*/\n    uint256 /*_configType*/\n  ) external pure override returns (bytes memory) {\n    return \"\";\n  }\n\n  function setSendVersion(\n    uint16 /*version*/\n  ) external override {}\n\n  function setReceiveVersion(\n    uint16 /*version*/\n  ) external override {}\n\n  function getSendVersion(\n    address /*_userApplication*/\n  ) external pure override returns (uint16) {\n    return 1;\n  }\n\n  function getReceiveVersion(\n    address /*_userApplication*/\n  ) external pure override returns (uint16) {\n    return 1;\n  }\n\n  function getInboundNonce(uint16 _chainID, bytes calldata _srcAddress) external view override returns (uint64) {\n    return inboundNonce[_chainID][_srcAddress];\n  }\n\n  function getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\n    return outboundNonce[_chainID][_srcAddress];\n  }\n\n  // simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\n  function _clearMsgQue(uint16 _srcChainId, bytes calldata _srcAddress) internal {\n    QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_srcAddress];\n\n    // warning, might run into gas issues trying to forward through a bunch of queued msgs\n    while (msgs.length > 0) {\n      QueuedPayload memory payload = msgs[msgs.length - 1];\n      ILayerZeroReceiver(payload.dstAddress).lzReceive(_srcChainId, _srcAddress, payload.nonce, payload.payload);\n      msgs.pop();\n    }\n  }\n\n  function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override {\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n    // revert if no messages are cached. safeguard malicious UA behaviour\n    require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n    require(sp.dstAddress == msg.sender, \"LayerZero: invalid caller\");\n\n    // empty the storedPayload\n    sp.payloadLength = 0;\n    sp.dstAddress = address(0);\n    sp.payloadHash = bytes32(0);\n\n    emit UaForceResumeReceive(_srcChainId, _srcAddress);\n\n    // resume the receiving of msgs after we force clear the \"stuck\" msg\n    _clearMsgQue(_srcChainId, _srcAddress);\n  }\n\n  function retryPayload(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    bytes calldata _payload\n  ) external override {\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n    require(sp.payloadHash != bytes32(0), \"LayerZero: no stored payload\");\n    require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, \"LayerZero: invalid payload\");\n\n    address dstAddress = sp.dstAddress;\n    // empty the storedPayload\n    sp.payloadLength = 0;\n    sp.dstAddress = address(0);\n    sp.payloadHash = bytes32(0);\n\n    uint64 nonce = inboundNonce[_srcChainId][_srcAddress];\n\n    ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _srcAddress, nonce, _payload);\n    emit PayloadCleared(_srcChainId, _srcAddress, nonce, dstAddress);\n  }\n\n  function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view override returns (bool) {\n    StoredPayload storage sp = storedPayload[_srcChainId][_srcAddress];\n    return sp.payloadHash != bytes32(0);\n  }\n\n  function isSendingPayload() external pure override returns (bool) {\n    return false;\n  }\n\n  function isReceivingPayload() external pure override returns (bool) {\n    return false;\n  }\n\n  function getSendLibraryAddress(address) external view override returns (address) {\n    return address(this);\n  }\n\n  function getReceiveLibraryAddress(address) external view override returns (address) {\n    return address(this);\n  }\n}\n"
    },
    "contracts/interface/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.13;\n\ninterface ILayerZeroReceiver {\n  // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n  // @param _srcChainId - the source endpoint identifier\n  // @param _srcAddress - the source sending contract address from the source chain\n  // @param _nonce - the ordered message nonce\n  // @param _payload - the signed payload is the UA bytes has encoded to be sent\n  function lzReceive(\n    uint16 _srcChainId,\n    bytes calldata _srcAddress,\n    uint64 _nonce,\n    bytes calldata _payload\n  ) external;\n}\n"
    },
    "contracts/mock/MockLZEndpoint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Admin.sol\";\n\ncontract MockLZEndpoint is Admin {\n  event LzEvent(uint16 _dstChainId, bytes _destination, bytes _payload);\n\n  constructor() {\n    assembly {\n      sstore(_adminSlot, origin())\n    }\n  }\n\n  function send(\n    uint16 _dstChainId,\n    bytes calldata _destination,\n    bytes calldata _payload,\n    address payable, /* _refundAddress*/\n    address, /* _zroPaymentAddress*/\n    bytes calldata /* _adapterParams*/\n  ) external payable {\n    // we really don't care about anything and just emit an event that we can leverage for multichain replication\n    emit LzEvent(_dstChainId, _destination, _payload);\n  }\n}\n"
    },
    "contracts/HolographRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./abstract/Admin.sol\";\nimport \"./abstract/Initializable.sol\";\n\nimport \"./interface/IHolograph.sol\";\nimport \"./interface/IInitializable.sol\";\n\n/**\n * @dev This smart contract stores the different source codes that have been prepared and can be used for bridging.\n * @dev We will store here the layer 1 for ERC721 and ERC1155 smart contracts.\n * @dev This way it can be super easy to upgrade/update the source code once, and have all smart contracts automatically updated.\n */\ncontract HolographRegistry is Admin, Initializable {\n  bytes32 constant _holographSlot = 0xb4107f746e9496e8452accc7de63d1c5e14c19f510932daa04077cd49e8bd77a;\n  bytes32 constant _utilityTokenSlot = 0xbf76518d46db472b71aa7677a0908b8016f3dee568415ffa24055f9a670f9c37;\n\n  /**\n   * @dev A list of smart contracts that are guaranteed secure and holographable.\n   */\n  mapping(address => bool) private _holographedContracts;\n\n  /**\n   * @dev A list of hashes and the mapped out contract addresses.\n   */\n  mapping(bytes32 => address) private _holographedContractsHashMap;\n\n  /**\n   * @dev Storage slot for saving contract type to contract address references.\n   */\n  mapping(bytes32 => address) private _contractTypeAddresses;\n\n  /**\n   * @dev Reserved type addresses for Admin.\n   *  Note: this is used for defining default contracts.\n   */\n  mapping(bytes32 => bool) private _reservedTypes;\n\n  /**\n   * @dev Mapping of all hTokens available for the different EVM chains\n   */\n  mapping(uint32 => address) private _hTokens;\n\n  /**\n   * @dev Array of all Holographable contracts that were ever deployed on this EVM chain\n   */\n  address[] private _holographableContracts;\n\n  /**\n   * @dev Constructor is left empty and only the admin address is set.\n   */\n  constructor() {}\n\n  /**\n   * @dev An array of initially reserved contract types for admin only to set.\n   */\n  function init(bytes memory data) external override returns (bytes4) {\n    require(!_isInitialized(), \"HOLOGRAPH: already initialized\");\n    (address holograph, bytes32[] memory reservedTypes) = abi.decode(data, (address, bytes32[]));\n    assembly {\n      sstore(_adminSlot, origin())\n      sstore(_holographSlot, holograph)\n    }\n    for (uint256 i = 0; i < reservedTypes.length; i++) {\n      _reservedTypes[reservedTypes[i]] = true;\n    }\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  /**\n   * @dev Allows to reference a deployed smart contract, and use it's code as reference inside of Holographers.\n   */\n  function referenceContractTypeAddress(address contractAddress) external returns (bytes32) {\n    bytes32 contractType;\n    assembly {\n      contractType := extcodehash(contractAddress)\n    }\n    require((contractType != 0x0 && contractType != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470), \"HOLOGRAPH: empty contract\");\n    require(_contractTypeAddresses[contractType] == address(0), \"HOLOGRAPH: contract already set\");\n    require(!_reservedTypes[contractType], \"HOLOGRAPH: reserved address type\");\n    _contractTypeAddresses[contractType] = contractAddress;\n    return contractType;\n  }\n\n  /**\n   * @dev Allows Holograph Factory to register a deployed contract, referenced with deployment hash.\n   */\n  function factoryDeployedHash(bytes32 hash, address contractAddress) external {\n    address holograph;\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n    require(msg.sender == IHolograph(holograph).getFactory(), \"HOLOGRAPH: factory only function\");\n    _holographedContractsHashMap[hash] = contractAddress;\n    _holographedContracts[contractAddress] = true;\n    _holographableContracts.push(contractAddress);\n  }\n\n  /**\n   * @dev Sets the contract address for a contract type.\n   */\n  function setContractTypeAddress(bytes32 contractType, address contractAddress) external onlyAdmin {\n    // For now we leave overriding as possible. need to think this through.\n    //require(_contractTypeAddresses[contractType] == address(0), \"HOLOGRAPH: contract already set\");\n    require(_reservedTypes[contractType], \"HOLOGRAPH: not reserved type\");\n    _contractTypeAddresses[contractType] = contractAddress;\n  }\n\n  /**\n   * @dev Sets the hToken address for a specific chain id.\n   */\n  function setHToken(uint32 chainId, address hToken) external onlyAdmin {\n    _hTokens[chainId] = hToken;\n  }\n\n  /**\n   * @dev Allows admin to update or toggle reserved types.\n   */\n  function updateReservedContractTypes(bytes32[] calldata hashes, bool[] calldata reserved) external onlyAdmin {\n    for (uint256 i = 0; i < hashes.length; i++) {\n      _reservedTypes[hashes[i]] = reserved[i];\n    }\n  }\n\n  /**\n   * @dev Returns the contract address for a contract type.\n   */\n  function getContractTypeAddress(bytes32 contractType) external view returns (address) {\n    return _contractTypeAddresses[contractType];\n  }\n\n  /**\n   * @dev Returns the address for a holographed hash\n   */\n  function getHolographedHashAddress(bytes32 hash) external view returns (address) {\n    return _holographedContractsHashMap[hash];\n  }\n\n  /**\n   * @dev Returns the hToken address for a given chain id.\n   */\n  function getHToken(uint32 chainId) external view returns (address) {\n    return _hTokens[chainId];\n  }\n\n  function getUtilityToken() external view returns (address tokenContract) {\n    assembly {\n      tokenContract := sload(_utilityTokenSlot)\n    }\n  }\n\n  function setUtilityToken(address tokenContract) external onlyAdmin {\n    assembly {\n      sstore(_utilityTokenSlot, tokenContract)\n    }\n  }\n\n  function isHolographedContract(address smartContract) external view returns (bool) {\n    return _holographedContracts[smartContract];\n  }\n\n  function isHolographedHashDeployed(bytes32 hash) external view returns (bool) {\n    return _holographedContractsHashMap[hash] != address(0);\n  }\n\n  function getHolograph() external view returns (address holograph) {\n    assembly {\n      holograph := sload(_holographSlot)\n    }\n  }\n\n  function setHolograph(address holograph) external onlyAdmin {\n    assembly {\n      sstore(_holographSlot, holograph)\n    }\n  }\n\n  /**\n   * @notice Get total number of deployed holographable contracts.\n   */\n  function getHolographableContractsLength() external view returns (uint256) {\n    return _holographableContracts.length;\n  }\n\n  /**\n   * @notice Get set length list, starting from index, for all holographable contracts.\n   * @param index The index to start enumeration from.\n   * @param length The length of returned results.\n   * @return contracts address[] Returns a set length array of holographable contracts deployed.\n   */\n  function holographableContracts(uint256 index, uint256 length) external view returns (address[] memory contracts) {\n    uint256 supply = _holographableContracts.length;\n    if (index + length > supply) {\n      length = supply - index;\n    }\n    contracts = new address[](length);\n    for (uint256 i = 0; i < length; i++) {\n      contracts[i] = _holographableContracts[index + i];\n    }\n  }\n}\n"
    },
    "contracts/HolographGenesis.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"./interface/IInitializable.sol\";\n\n/**\n * @dev In the beginning there was a smart contract...\n */\ncontract HolographGenesis {\n  mapping(address => bool) private _approvedDeployers;\n\n  event Message(string message);\n\n  modifier onlyDeployer() {\n    require(_approvedDeployers[msg.sender], \"HOLOGRAPH: deployer not approved\");\n    _;\n  }\n\n  constructor() {\n    _approvedDeployers[tx.origin] = true;\n    emit Message(\"The future of NFTs is Holograph.\");\n  }\n\n  function deploy(\n    uint256 chainId,\n    bytes12 saltHash,\n    bytes memory sourceCode,\n    bytes memory initCode\n  ) external onlyDeployer {\n    require(chainId == block.chainid, \"HOLOGRAPH: incorrect chain id\");\n    bytes32 salt = bytes32(abi.encodePacked(msg.sender, saltHash));\n    address contractAddress = address(\n      uint160(uint256(keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(sourceCode)))))\n    );\n    require(!_isContract(contractAddress), \"HOLOGRAPH: already deployed\");\n    assembly {\n      contractAddress := create2(0, add(sourceCode, 0x20), mload(sourceCode), salt)\n    }\n    require(_isContract(contractAddress), \"HOLOGRAPH: deployment failed\");\n    require(\n      IInitializable(contractAddress).init(initCode) == IInitializable.init.selector,\n      \"HOLOGRAPH: initialization failed\"\n    );\n  }\n\n  function approveDeployer(address newDeployer, bool approve) external onlyDeployer {\n    _approvedDeployers[newDeployer] = approve;\n  }\n\n  function isApprovedDeployer(address deployer) external view returns (bool) {\n    return _approvedDeployers[deployer];\n  }\n\n  function _isContract(address contractAddress) internal view returns (bool) {\n    bytes32 codehash;\n    assembly {\n      codehash := extcodehash(contractAddress)\n    }\n    return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n  }\n}\n"
    },
    "contracts/abstract/ERC1155H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../abstract/Initializable.sol\";\n\nabstract contract ERC1155H is Initializable {\n  bytes32 constant _holographerSlot = 0xe9fcff60011c1a99f7b7244d1f2d9da93d79ea8ef3654ce590d775575255b2bd;\n  bytes32 constant _ownerSlot = 0xb56711ba6bd3ded7639fc335ee7524fe668a79d7558c85992e3f8494cf772777;\n\n  modifier onlyHolographer() {\n    require(msg.sender == holographer(), \"ERC1155: holographer only\");\n    _;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == holographer()) {\n      require(msgSender() == _getOwner(), \"ERC1155: owner only function\");\n    } else {\n      require(msg.sender == _getOwner(), \"ERC1155: owner only function\");\n    }\n    _;\n  }\n\n  /**\n   * @notice Constructor is empty and not utilised.\n   * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n   */\n  constructor() {}\n\n  /**\n   * @notice Initializes the collection.\n   * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n   */\n  function init(bytes memory data) external virtual override returns (bytes4) {\n    return _init(data);\n  }\n\n  function _init(\n    bytes memory /* data*/\n  ) internal returns (bytes4) {\n    require(!_isInitialized(), \"ERC1155: already initialized\");\n    address _holographer = msg.sender;\n    assembly {\n      sstore(_holographerSlot, _holographer)\n    }\n    _setInitialized();\n    return IInitializable.init.selector;\n  }\n\n  /**\n   * @dev The Holographer passes original msg.sender via calldata. This function extracts it.\n   */\n  function msgSender() internal pure returns (address sender) {\n    assembly {\n      sender := calldataload(sub(calldatasize(), 0x20))\n    }\n  }\n\n  /**\n   * @dev Address of Holograph ERC1155 standards enforcer smart contract.\n   */\n  function holographer() internal view returns (address _holographer) {\n    assembly {\n      _holographer := sload(_holographerSlot)\n    }\n  }\n\n  function supportsInterface(bytes4) external pure returns (bool) {\n    return false;\n  }\n\n  /**\n   * @dev Address of initial creator/owner of the collection.\n   */\n  function owner() external view returns (address) {\n    return _getOwner();\n  }\n\n  function isOwner() external view returns (bool) {\n    if (msg.sender == holographer()) {\n      return msgSender() == _getOwner();\n    } else {\n      return msg.sender == _getOwner();\n    }\n  }\n\n  function isOwner(address wallet) external view returns (bool) {\n    return wallet == _getOwner();\n  }\n\n  function _getOwner() internal view returns (address ownerAddress) {\n    assembly {\n      ownerAddress := sload(_ownerSlot)\n    }\n  }\n\n  function _setOwner(address ownerAddress) internal {\n    assembly {\n      sstore(_ownerSlot, ownerAddress)\n    }\n  }\n\n  /**\n   * @dev Defined here to suppress compiler warnings\n   */\n  receive() external payable {}\n\n  /**\n   * @dev Return true for any un-implemented event hooks\n   */\n  fallback() external payable {\n    assembly {\n      switch eq(sload(_holographerSlot), caller())\n      case 1 {\n        mstore(0x80, 0x0000000000000000000000000000000000000000000000000000000000000001)\n        return(0x80, 0x20)\n      }\n      default {\n        revert(0x00, 0x00)\n      }\n    }\n  }\n}\n"
    },
    "contracts/abstract/StrictERC1155H.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nimport \"../interface/HolographedERC1155.sol\";\n\nimport \"./ERC1155H.sol\";\n\nabstract contract StrictERC1155H is ERC1155H, HolographedERC1155 {\n  /**\n   * @dev Dummy variable to prevent empty functions from making \"switch to pure\" warnings.\n   */\n  bool private _success;\n\n  function bridgeIn(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool) {\n    _success = true;\n    return true;\n  }\n\n  function bridgeOut(\n    uint32, /* _chainId*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bytes memory _data) {\n    _success = true;\n    _data = abi.encode(holographer());\n  }\n\n  function afterApprove(\n    address, /* _owner*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprove(\n    address, /* _owner*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterApprovalAll(\n    address, /* _to*/\n    bool /* _approved*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeApprovalAll(\n    address, /* _to*/\n    bool /* _approved*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterBurn(\n    address, /* _owner*/\n    uint256, /* _tokenId*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeBurn(\n    address, /* _owner*/\n    uint256, /* _tokenId*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterMint(\n    address, /* _owner*/\n    uint256, /* _tokenId*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeMint(\n    address, /* _owner*/\n    uint256, /* _tokenId*/\n    uint256 /* _amount*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterSafeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeSafeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeTransfer(\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function afterOnERC1155Received(\n    address, /* _operator*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n\n  function beforeOnERC1155Received(\n    address, /* _operator*/\n    address, /* _from*/\n    address, /* _to*/\n    uint256, /* _tokenId*/\n    uint256, /* _amount*/\n    bytes calldata /* _data*/\n  ) external virtual onlyHolographer returns (bool success) {\n    _success = true;\n    return _success;\n  }\n}\n"
    },
    "contracts/interface/HolographedERC1155.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\n/// @title Holograph ERC-1155 Non-Fungible Token Standard\n/// @dev See https://holograph.network/standard/ERC-1155\n///  Note: the ERC-165 identifier for this interface is 0xFFFFFFFF.\ninterface HolographedERC1155 {\n  // event id = 1\n  function bridgeIn(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 2\n  function bridgeOut(\n    uint32 _chainId,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bytes memory _data);\n\n  // event id = 3\n  function afterApprove(\n    address _owner,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 4\n  function beforeApprove(\n    address _owner,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 5\n  function afterApprovalAll(address _to, bool _approved) external returns (bool success);\n\n  // event id = 6\n  function beforeApprovalAll(address _to, bool _approved) external returns (bool success);\n\n  // event id = 7\n  function afterBurn(\n    address _owner,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 8\n  function beforeBurn(\n    address _owner,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 9\n  function afterMint(\n    address _owner,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 10\n  function beforeMint(\n    address _owner,\n    uint256 _tokenId,\n    uint256 _amount\n  ) external returns (bool success);\n\n  // event id = 11\n  function afterSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 12\n  function beforeSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 13\n  function afterTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 14\n  function beforeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 15\n  function afterOnERC1155Received(\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n\n  // event id = 16\n  function beforeOnERC1155Received(\n    address _operator,\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    uint256 _amount,\n    bytes calldata _data\n  ) external returns (bool success);\n}\n"
    },
    "contracts/interface/ERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity 0.8.13;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface ERC1271 {\n  /**\n   * @dev Should return whether the signature provided is valid for the provided data\n   * @param hash      Hash of the data to be signed\n   * @param signature Signature byte array associated with _data\n   */\n  function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "contracts/library/Bytes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Bytes {\n  function getBoolean(uint192 _packedBools, uint192 _boolNumber) internal pure returns (bool) {\n    uint192 flag = (_packedBools >> _boolNumber) & uint192(1);\n    return (flag == 1 ? true : false);\n  }\n\n  function setBoolean(\n    uint192 _packedBools,\n    uint192 _boolNumber,\n    bool _value\n  ) internal pure returns (uint192) {\n    if (_value) {\n      return _packedBools | (uint192(1) << _boolNumber);\n    } else {\n      return _packedBools & ~(uint192(1) << _boolNumber);\n    }\n  }\n\n  function slice(\n    bytes memory _bytes,\n    uint256 _start,\n    uint256 _length\n  ) internal pure returns (bytes memory) {\n    require(_length + 31 >= _length, \"slice_overflow\");\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n    bytes memory tempBytes;\n    assembly {\n      switch iszero(_length)\n      case 0 {\n        tempBytes := mload(0x40)\n        let lengthmod := and(_length, 31)\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n        let end := add(mc, _length)\n        for {\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n        } lt(mc, end) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          mstore(mc, mload(cc))\n        }\n        mstore(tempBytes, _length)\n        mstore(0x40, and(add(mc, 31), not(31)))\n      }\n      default {\n        tempBytes := mload(0x40)\n        mstore(tempBytes, 0)\n        mstore(0x40, add(tempBytes, 0x20))\n      }\n    }\n    return tempBytes;\n  }\n\n  function trim(bytes32 source) internal pure returns (bytes memory) {\n    uint256 temp = uint256(source);\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return slice(abi.encodePacked(source), 32 - length, length);\n  }\n}\n"
    },
    "contracts/library/Signature.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Signature {\n  function Derive(\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    bytes memory encoded\n  )\n    internal\n    pure\n    returns (\n      address derived1,\n      address derived2,\n      address derived3,\n      address derived4\n    )\n  {\n    bytes32 encoded32;\n    assembly {\n      encoded32 := mload(add(encoded, 32))\n    }\n    derived1 = ecrecover(encoded32, v, r, s);\n    derived2 = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)), v, r, s);\n    encoded32 = keccak256(encoded);\n    derived3 = ecrecover(encoded32, v, r, s);\n    encoded32 = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32));\n    derived4 = ecrecover(encoded32, v, r, s);\n  }\n\n  function PackMessage(bytes memory encoded, bool geth) internal pure returns (bytes32) {\n    bytes32 hash = keccak256(encoded);\n    if (geth) {\n      hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n    return hash;\n  }\n\n  function Valid(\n    address target,\n    bytes32 r,\n    bytes32 s,\n    uint8 v,\n    bytes memory encoded\n  ) internal pure returns (bool) {\n    bytes32 encoded32;\n    address derived;\n    if (encoded.length == 32) {\n      assembly {\n        encoded32 := mload(add(encoded, 32))\n      }\n      derived = ecrecover(encoded32, v, r, s);\n      if (target == derived) {\n        return true;\n      }\n      derived = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)), v, r, s);\n      if (target == derived) {\n        return true;\n      }\n    }\n    bytes32 hash = keccak256(encoded);\n    derived = ecrecover(hash, v, r, s);\n    if (target == derived) {\n      return true;\n    }\n    hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    derived = ecrecover(hash, v, r, s);\n    return target == derived;\n  }\n}\n"
    },
    "contracts/library/Storage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/*\n\n                         ┌───────────┐\n                         │ HOLOGRAPH │\n                         └───────────┘\n╔═════════════════════════════════════════════════════════════╗\n║                                                             ║\n║                            / ^ \\                            ║\n║                            ~~*~~            ¸               ║\n║                         [ '<>:<>' ]         │░░░            ║\n║               ╔╗           _/\"\\_           ╔╣               ║\n║             ┌─╬╬─┐          \"\"\"          ┌─╬╬─┐             ║\n║          ┌─┬┘ ╠╣ └┬─┐       \\_/       ┌─┬┘ ╠╣ └┬─┐          ║\n║       ┌─┬┘ │  ╠╣  │ └┬─┐           ┌─┬┘ │  ╠╣  │ └┬─┐       ║\n║    ┌─┬┘ │  │  ╠╣  │  │ └┬─┐     ┌─┬┘ │  │  ╠╣  │  │ └┬─┐    ║\n║ ┌─┬┘ │  │  │  ╠╣  │  │  │ └┬┐ ┌┬┘ │  │  │  ╠╣  │  │  │ └┬─┐ ║\n╠┬┘ │  │  │  │  ╠╣  │  │  │  │└¤┘│  │  │  │  ╠╣  │  │  │  │ └┬╣\n║│  │  │  │  │  ╠╣  │  │  │  │   │  │  │  │  ╠╣  │  │  │  │  │║\n╠╩══╩══╩══╩══╩══╬╬══╩══╩══╩══╩═══╩══╩══╩══╩══╬╬══╩══╩══╩══╩══╩╣\n╠┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╬╬┴┴┴┴┴┴┴┴┴┴┴┴┴┴┴╣\n║               ╠╣                           ╠╣               ║\n║               ╠╣                           ╠╣               ║\n║    ,          ╠╣     ,        ,'      *    ╠╣               ║\n║~~~~~^~~~~~~~~┌╬╬┐~~~^~~~~~~~~^^~~~~~~~~^~~┌╬╬┐~~~~~~~^~~~~~~║\n╚══════════════╩╩╩╩═════════════════════════╩╩╩╩══════════════╝\n     - one protocol, one bridge = infinite possibilities -\n\n\n ***************************************************************\n\n DISCLAIMER: U.S Patent Pending\n\n LICENSE: Holograph Limited Public License (H-LPL)\n\n https://holograph.xyz/licenses/h-lpl/1.0.0\n\n This license governs use of the accompanying software. If you\n use the software, you accept this license. If you do not accept\n the license, you are not permitted to use the software.\n\n 1. Definitions\n\n The terms \"reproduce,\" \"reproduction,\" \"derivative works,\" and\n \"distribution\" have the same meaning here as under U.S.\n copyright law. A \"contribution\" is the original software, or\n any additions or changes to the software. A \"contributor\" is\n any person that distributes its contribution under this\n license. \"Licensed patents\" are a contributor’s patent claims\n that read directly on its contribution.\n\n 2. Grant of Rights\n\n A) Copyright Grant- Subject to the terms of this license,\n including the license conditions and limitations in sections 3\n and 4, each contributor grants you a non-exclusive, worldwide,\n royalty-free copyright license to reproduce its contribution,\n prepare derivative works of its contribution, and distribute\n its contribution or any derivative works that you create.\n B) Patent Grant- Subject to the terms of this license,\n including the license conditions and limitations in section 3,\n each contributor grants you a non-exclusive, worldwide,\n royalty-free license under its licensed patents to make, have\n made, use, sell, offer for sale, import, and/or otherwise\n dispose of its contribution in the software or derivative works\n of the contribution in the software.\n\n 3. Conditions and Limitations\n\n A) No Trademark License- This license does not grant you rights\n to use any contributors’ name, logo, or trademarks.\n B) If you bring a patent claim against any contributor over\n patents that you claim are infringed by the software, your\n patent license from such contributor is terminated with\n immediate effect.\n C) If you distribute any portion of the software, you must\n retain all copyright, patent, trademark, and attribution\n notices that are present in the software.\n D) If you distribute any portion of the software in source code\n form, you may do so only under this license by including a\n complete copy of this license with your distribution. If you\n distribute any portion of the software in compiled or object\n code form, you may only do so under a license that complies\n with this license.\n E) The software is licensed “as-is.” You bear all risks of\n using it. The contributors give no express warranties,\n guarantees, or conditions. You may have additional consumer\n rights under your local laws which this license cannot change.\n To the extent permitted under your local laws, the contributors\n exclude all implied warranties, including those of\n merchantability, fitness for a particular purpose and\n non-infringement.\n\n 4. (F) Platform Limitation- The licenses granted in sections\n 2.A & 2.B extend only to the software or derivative works that\n you create that run on a Holograph system product.\n\n ***************************************************************\n\n*/\n\npragma solidity 0.8.13;\n\nlibrary Storage {\n  function getUint32(bytes32 slot) internal view returns (uint32 output) {\n    assembly {\n      output := sload(slot)\n    }\n  }\n\n  function setUint32(bytes32 slot, uint32 input) internal {\n    assembly {\n      sstore(slot, input)\n    }\n  }\n\n  function getUint256(bytes32 slot) internal view returns (uint256 output) {\n    assembly {\n      output := sload(slot)\n    }\n  }\n\n  function setUint256(bytes32 slot, uint256 input) internal {\n    assembly {\n      sstore(slot, input)\n    }\n  }\n\n  function getAddress(bytes32 slot) internal view returns (address output) {\n    assembly {\n      output := sload(slot)\n    }\n  }\n\n  function setAddress(bytes32 slot, address input) internal {\n    assembly {\n      sstore(slot, input)\n    }\n  }\n\n  function getBytes32(bytes32 slot) internal view returns (bytes32 output) {\n    assembly {\n      output := sload(slot)\n    }\n  }\n\n  function setBytes32(bytes32 slot, bytes32 input) internal {\n    assembly {\n      sstore(slot, input)\n    }\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "libraries": {}
  }
}
